{
    "version": "https://jsonfeed.org/version/1",
    "title": "virtualguard's Blog • All posts by \"docker\" tag",
    "description": "</>",
    "home_page_url": "http://blog.virtualguard101.xyz",
    "items": [
        {
            "id": "http://blog.virtualguard101.xyz/2025/06/23/web/",
            "url": "http://blog.virtualguard101.xyz/2025/06/23/web/",
            "title": "个人站点构建要点(改良版) && Web 开发简要实践",
            "date_published": "2025-06-23T04:38:07.000Z",
            "content_html": "<p><strong>对今年四月份写的“docker-compose + nginx快速构建个人站点”中提到的构建方式作一下改良，同时根据学到的技能添加一些自定义的玩意，2025暑假期间持续更新</strong></p>\n<p>近期在<a href=\"https://www.spaceship.com/zh/\">spaceship</a>上订阅了一个新的域名；同时还订阅了一台美国硅谷的VPS用于重构我的个人站点，也可以理解为是要搭第二个个人站点。</p>\n<p>做出这个决定的原因，一方面是想精进自己web开发的能力，多点亮一些相关的技能树；另一方面，第一个站点的服务器配置已经被我搅成一坨了——虽然还称不上💩山，但我实在是懒得整理了，干脆直接搞台新的来重构；同时新服务器的连接速度比原来那个快上不少也是一个原因，这样虽然还称不上是“方便管理”，但提供点情绪价值还是有的。</p>\n<!-- more -->\n<h2 id=\"部署要点-杂项\"><a class=\"markdownIt-Anchor\" href=\"#部署要点-杂项\"></a> 部署要点 &amp; 杂项</h2>\n<h3 id=\"部署改良\"><a class=\"markdownIt-Anchor\" href=\"#部署改良\"></a> 部署改良</h3>\n<h4 id=\"改良要点\"><a class=\"markdownIt-Anchor\" href=\"#改良要点\"></a> 改良要点</h4>\n<p>在今年的四月份我曾发布了一篇<a href=\"https://blog.virtualguard101.xyz/2025/04/26/web-build/\">文章</a>，里面主要提及了 <strong>Docker Compose + Nginx</strong> “一键部署”的部署方式。如果所部署的服务模块基本高度稳定，基本不需要通过暂停服务来处理集成/交付问题，或者服务之间几乎不存在依赖关系或依赖关系十分简单，那么这这种部署方式就不会有什么太大的问题；然而，倘若需要灵活的开发场景，例如需要经常性为站点添加新的服务，或是存在需要通过停止服务来进行配置的服务，同时服务与服务之间的依赖关系错综复杂，使用这样<strong>一体化</strong>的部署方式就需要将所有服务一并停止，这样就不利于高效开发且会降低站点的可访问性。</p>\n<p>会降低可访问性很好理解——需要频繁地关闭服务在访问者眼里就是不稳定的表现。对于不利于高效开发的问题我们举一个例子：假设你想部署一个服务，但是这个服务需要调用另一个同样部署在该主机上的某个服务的API。为了添加这个服务，你首先需要把该主机上部署的所有服务先通过<code>docker compose down</code>停止运行，然后添加这个服务的配置；在正式部署前，你想要测试一下这个服务的功能如何，结果发现依赖的API无法调用——因为它被停止了；然后你索性就不测试了，直接<code>docker compose up -d</code>一键部署，结果配置出了问题——运气好点的话，只有新服务的容器无法运行；运气不好的话，新服务可能执行了一个未定义行为在，或者传入了一个未定义参数到API服务里，结果导致API服务也崩溃了，依赖这个API服务的其他服务也就跟着崩溃了，留下一大堆与看上去新服务毫无关联的报错信息和阅读着如💩山一般报错信息风中凌乱的你…原本只要看一个服务的报错，现在要看好几个，而且其中的依赖关系可能还很复杂！那样的报错信息懂的都懂，根本就不是给人看的。这种情况就会大大增加debug的压力，也就降低了开发效率。</p>\n<p>解决这个问题，我们就需要通过把原来高度集中的微服务分散开来配置与部署来解决可能被“一锅端”的问题。针对普通的个人站点，实现的思路也很简单，现成服务的部署工具仍然是Docker + Nginx，但这次我们将二者独立开来。简单来说，旧版的部署方式是<strong>将Nginx的转发服务也一并运行于Docker</strong>，各个由Nginx转发的子服务由Docker部署，<strong>所有的服务均配置于单个<code>docker-compose.yml</code>中</strong>，可参考下图理解：</p>\n<pre class=\"mermaid\">stateDiagram-v2\n\n  A: docker-compose.yml\n  state A {\n    [*] --> service1\n    [*] --> service2\n    [*] --> ........\n    [*] --> serviceN\n\n    B: Backend Services\n    state B {\n      service1 --> Nginx: forward\n      service2 --> Nginx: forward\n      ........ --> Nginx: forward\n      serviceN --> Nginx: forward\n    }\n\n    state Nginx {\n      Description: High-performance Web Server and Reverse Proxy Handle\n    }\n  }\n\n  Nginx --> Front</pre>\n<p>而我们现在的思路则是将不同服务的<strong>部署配置</strong>(这里特指<code>docker-compose.yml</code>)分散到各个服务独立的配置路径上进行配置并由Docker部署，最后由运行于全局环境的Nginx进行转发：</p>\n<pre class=\"mermaid\">stateDiagram-v2\n\n  A: Backend Services\n  state A {\n    B: docker-compose.yml\n    C: docker-compose.yml\n    D: docker-compose.ymls\n    E: docker-compose.yml\n\n    state B {\n      [*] --> service1\n    }\n\n    state C {\n      [*] --> service2\n    }\n\n    state D {\n      [*] --> ........\n    }\n\n    state E {\n      [*] --> serviceN\n    }\n  }\n\n  state Nginx {\n    Description: High-performance Web Server and Reverse Proxy Handle(Running Globally)\n  }\n\n  service1 --> Nginx: forward\n  service2 --> Nginx: forward\n  ........ --> Nginx: forward\n  serviceN --> Nginx: forward\n\n  Nginx --> Front</pre>\n<p>理论存在，接下来就是 <s>魔法时间</s> 实际配置了。</p>\n<h4 id=\"部署流程\"><a class=\"markdownIt-Anchor\" href=\"#部署流程\"></a> 部署流程</h4>\n<h5 id=\"环境配置\"><a class=\"markdownIt-Anchor\" href=\"#环境配置\"></a> 环境配置</h5>\n<p>首先是配置环境依赖。对于服务器和域名的配置这里补充一个为服务器添加交换空间的<a href=\"https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-22-04#step-3-creating-a-swap-file\">教程</a>（对于“什么是交换空间”、“交换空间有什么用”，这篇教程描述得足够详尽了），其余部分不再赘述，主要看看两个部署工具以及一些可能需要用到的工具的配置</p>\n<ul>\n<li>\n<p>Docker</p>\n<ul>\n<li>安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com | bash -s docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure>\n</li>\n<li>配置用户组<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> groupadd docker <span class=\"comment\"># 若尚不存在 docker 组，则需先创建</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n配置完用户组后需要重启使配置生效。</li>\n</ul>\n</li>\n<li>\n<p>Nginx</p>\n<ul>\n<li>从前面的理论方案中我们知道，这次的Nginx不再运行于容器之中，而是运行在全局环境下的，因此我们需要在服务器上安装它：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install nginx</span><br></pre></td></tr></table></figure>\n</li>\n<li>将Nginx服务设置为开机自启<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl <span class=\"built_in\">enable</span> nginx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>certbot（SSL证书申请工具）</p>\n<ul>\n<li>安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install certbot</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>cron（定时任务）</p>\n<ul>\n<li>安装<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install cron</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"目录结构\"><a class=\"markdownIt-Anchor\" href=\"#目录结构\"></a> 目录结构</h5>\n<p>配置完环境依赖，我们就可以开始为部署做准备了，首当其冲的自然是为不同的分别服务创建独立的配置与数据空间。</p>\n<p>在改良理论方案中我们提到，要为每个微服务独立配置一个<code>docker-compose.yml</code>以实现不同服务之间的相互独立与互不干扰——这是与旧方案最为本质的区别；但在目录创建与管理上，我们现在所介绍的新方案则与旧方案没有太大的区别。下面是一个针对新方案的web服务目录结构案例（其中包含了两个后端服务）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/webservices</span><br><span class=\"line\">├── service1</span><br><span class=\"line\">│   ├── config</span><br><span class=\"line\">│   │   └── config.json</span><br><span class=\"line\">│   ├── docker-compose.yml</span><br><span class=\"line\">│   ├── fonts</span><br><span class=\"line\">│   └── icons</span><br><span class=\"line\">├── nginx -&gt; /etc/nginx</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">│   ├── servicesManager.sh</span><br><span class=\"line\">│   └── sslrenew.sh</span><br><span class=\"line\">└── service2</span><br><span class=\"line\">    ├── docker-compose.yml</span><br><span class=\"line\">    └── data</span><br><span class=\"line\">        └── .....</span><br></pre></td></tr></table></figure>\n<p>对于我们需要部署的后端服务而言，每个微服务的配置仍然分属于各个目录中。与旧方案唯一的不同地方就是各个服务的目录下都多了一个属于它们自己的<code>docker-compose.yml</code>，相当于把旧方案中存在与web服务集群根目录的<code>docker-compose.yml</code>配置肢解到各个服务独立的目录中。</p>\n<p>这里你可能会发现nginx的目录是一个<strong>软链接</strong>，关于这个我们接下来在<a href=\"#Nginx%E7%9A%84%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE\">Nginx的配置</a>中介绍。</p>\n<h5 id=\"nginx的全局配置\"><a class=\"markdownIt-Anchor\" href=\"#nginx的全局配置\"></a> Nginx的全局配置</h5>\n<p>对于各个服务<code>docker-compose.yml</code>的配置这里基本没有新的东西可以介绍，其中一个比较明显的区别就是网路环境变成全局的了，所以不用在额外配置<code>networks</code>参数。</p>\n<p>最主要的区别还是在<code>nginx.conf</code>的配置上，因此我们接下来详细介绍。</p>\n<p>由于这次的Nginx运行在全局环境下，自然也需要通过编辑全局的配置文件来驱动其执行转发服务。</p>\n<blockquote>\n<p>在Linux中，Nginx的全局配置<code>nginx.conf</code>位于路径<code>/etc/nginx</code>下，需要<strong>sudo提权</strong>才可以保存配置，如果使用vscode的远程资源管理器连接的服务器，可能无法直接在窗口上直接使用vscode编辑<code>nginx.conf</code>，比较方便且安全的解决方法有两个：一是直接在终端上提权使用vim对目标文件进行编辑 <s>那我还用vscode干什么</s>；还有一个就是安装插件<a href=\"https://marketplace.visualstudio.com/items?itemName=yy0931.save-as-root\">Save as Root in Remote</a>，通过插件提权保存。</p>\n<p>同时，如果是使用vscode进行的远程连接，可以在通过在web服务集群的根目录下创建Nginx配置目录(<code>/etc/nginx</code>)和日志目录(<code>/var/log/nginx</code>)的<strong>软链接</strong>来提高开发效率</p>\n</blockquote>\n<p>事实上，新方案在配置内容上只需要修改几个参数，总体的配置可能比旧方案还更好理解，下面给出一个简单的例子：</p>\n<p>假设有一个待转发的服务运行于主机的5000端口上，那么有以下配置模板可供参考（注意需要插入到合理的位置，<code>nginx.conf</code>在安装Nginx时通常会自带一些配置；在这里，“合理的位置”<strong>至少</strong>指的是要在<code>http</code>模块中）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 80;</span><br><span class=\"line\">\t# listen [::]:80;</span><br><span class=\"line\"></span><br><span class=\"line\">\tserver_name  your_domain.here;</span><br><span class=\"line\">\tserver_tokens off;</span><br><span class=\"line\"></span><br><span class=\"line\">\t#配置http验证可访问</span><br><span class=\"line\">\tlocation /.well-known/acme-challenge/ &#123;</span><br><span class=\"line\">\t\troot /usr/share/certbot/www;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t#http跳转到https</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\treturn 301 https://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#  server &#123;</span><br><span class=\"line\"> #   listen 80;</span><br><span class=\"line\">#   server_name  your_domain.here;</span><br><span class=\"line\"></span><br><span class=\"line\"> #   location / &#123;</span><br><span class=\"line\"> #     proxy_pass http://127.0.0.1:5000;</span><br><span class=\"line\"> #     proxy_set_header Host $host;</span><br><span class=\"line\"> #     proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\"> #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\"> #     proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\"> #   &#125;       </span><br><span class=\"line\"> #   # 强制HTTPS重定向</span><br><span class=\"line\"> #   # return 301 https://$host$request_uri;</span><br><span class=\"line\"> # &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 443 ssl http2;</span><br><span class=\"line\">\tserver_name  your_domain.here;</span><br><span class=\"line\"></span><br><span class=\"line\">\tssl_certificate /etc/letsencrypt/live/your_domina.here/fullchain.pem;</span><br><span class=\"line\">\tssl_certificate_key /etc/letsencrypt/live/your_domain.here/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\tproxy_pass http://127.0.0.1:5000;</span><br><span class=\"line\">\t\tproxy_set_header Host $host;</span><br><span class=\"line\">\t\tproxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">\t\tproxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>配置上的原理也很简单，简单理解就是在用户访问运行于<code>80</code>/<code>443</code>的HTTP/HTTPS服务时，将运行于<code>5000</code>端口上的后端服务作一次转发。</p>\n<blockquote>\n<p>⚠️注意在<code>docker-compose.yml</code>中，<code>port</code>参数<code>:</code>前的端口号才是宿主机的端口号，也就是我们需要写入<code>nginx.conf</code>的端口号</p>\n</blockquote>\n<h5 id=\"ssl证书申请\"><a class=\"markdownIt-Anchor\" href=\"#ssl证书申请\"></a> SSL证书申请</h5>\n<p>第一次申请的操作和定时任务的配置可以参考<a href=\"https://kasuie.cc/article/22\">这篇文章</a></p>\n<p>虽然已经运行了Nginx服务，但我们仍然可以通过<code>standalone</code>模式获取证书，但这需要先将Nginx服务关闭以释放<code>80</code>端口，否则会提示端口被占用而无法申请；申请完证书后再重新启动Nginx即可。当然，也可通过<code>webroot</code>模式直接申请。</p>\n<blockquote>\n<p>⚠️由于使用certbot时需要提权运行，所以在配置定时任务时也需要进行sudo提权：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> crontab -e</span><br></pre></td></tr></table></figure>\n<p>否则可能会遇到定时任务无权限运行certbot的尴尬情况</p>\n</blockquote>\n<h5 id=\"服务管理脚本\"><a class=\"markdownIt-Anchor\" href=\"#服务管理脚本\"></a> 服务管理脚本</h5>\n<p>当服务数量越来越多，且依赖关系越来越复杂时，每次需要配置一个服务可能就需要频繁地切换目录以及输入一些冗长的命令，这时就可以通过编写自动化脚本来 <s>偷懒</s> 提高效率。</p>\n<p>对于逻辑比较简单（比如线性逻辑）且shell命令相对密集的系列操作，我们就可以通过编写shell脚本来解决；而对于逻辑相对复杂且需要高度定制化的系列操作，我们就可以交给python脚本来解决，这样不容易出错。</p>\n<p>编写python脚本前，我们需要先安装python：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install python3</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt install pip</span><br></pre></td></tr></table></figure>\n<p>Ubuntu默认安装python3.10，如果对版本有特殊要求，可以安装一个虚拟环境管理器。这里以<a href=\"https://docs.astral.sh/uv/\">uv</a>为例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -LsSf https://astral.sh/uv/install.sh | sh</span><br></pre></td></tr></table></figure>\n<!-- [ ] 脚本模板案例 -->\n",
            "tags": [
                "web开发",
                "docker"
            ]
        },
        {
            "id": "http://blog.virtualguard101.xyz/2025/04/26/web-build/",
            "url": "http://blog.virtualguard101.xyz/2025/04/26/web-build/",
            "title": "docker-compose + nginx快速构建个人站点",
            "date_published": "2025-04-26T15:28:57.000Z",
            "content_html": "<p><strong>本文主要讲解如何从零开始利用docker-compose + nginx快速构建一个个人站点；并利用Github Action实现文章部署自动化；最后是如何使用certbot为站点自动化申请ssl证书。整套配置流程做下来用时基本上不会超过3天</strong></p>\n<p>起因是我决定搭建一个个人站点用于模块化整合资源，在搜罗主页主题时因为部署简单相中了<a href=\"https://github.com/kasuie/remio-home\">remio-home | kasuie</a>，有多简单呢？简单到只需要进行一些及其简单的配置（cv大法可用）后，在服务器上输入一行<code>docker-compose up -d</code>即可。结合大佬的一些建议和我自己的一些 <s>偷懒</s> 自动化的想法，便有了下文。</p>\n<p>如题，本文主要讲解如何从零开始在一台云服务器上利用docker-compose + nginx快速构建一个个人站点。得益于强大的现代化工具链以及开源社区的支持，我们完成这个简易项目所需的计算机理论基础并不多，甚至可以说是几乎为零，只需要知道文档应该怎么读，如何正确打开开发中的“cv大法”来为自己的自动化工具链编写配置文件。当然，最好有一点web开发的基础，这样在遇到意料之外的问题时不至于束手无策。</p>\n<!-- more -->\n<p>通过该项目你会了解到以下内容：</p>\n<ul>\n<li><strong>1. 远程服务器的基础使用</strong></li>\n<li><strong>2. docker、docker-compose部署服务的基础操作</strong></li>\n<li><strong>3. web开发实现原理基础——静态资源部署</strong></li>\n<li><strong>4. hexo静态网页生成工具的使用</strong></li>\n<li><strong>5. Github Action配置自动化部署</strong></li>\n<li><strong>6. nginx基础配置（反向代理、二级域名）</strong></li>\n<li><strong>7. 在容器内使用certbot申请ssl证书，并通过定时任务自动化续签</strong></li>\n</ul>\n<p>下面是完成该项目所需的基础条件：</p>\n<ul>\n<li>一台服务器</li>\n<li>一个有效域名</li>\n</ul>\n<p><strong>服务器</strong>可在云服务器运营商处租用。国内比较可靠的运营商有阿里云、腾讯云等。</p>\n<p><strong>域名</strong>同样需要在运营商购买，也可通过特殊手段申请免费域名（不过免费申请的域名如有人出钱购买就会被回收）。获得域名后根据DNS云解析平台的文档进行解析配置即可。</p>\n<h2 id=\"准备工作\"><a class=\"markdownIt-Anchor\" href=\"#准备工作\"></a> 准备工作</h2>\n<h3 id=\"部署环境\"><a class=\"markdownIt-Anchor\" href=\"#部署环境\"></a> 部署环境</h3>\n<p>服务器的初始配置可参考这篇文章<a href=\"https://note.virtualguard101.xyz/notes/%E5%B7%A5%E5%85%B7/ssh/\">远程服务器的基础使用</a>，这里不再赘述。由于需要使用<code>docker</code>进行部署，我们需要先在服务器上安装一下docker。通过以下命令安装：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -fsSL https://get.docker.com | bash -s docker</span><br><span class=\"line\"><span class=\"built_in\">sudo</span> apt install docker-compose</span><br></pre></td></tr></table></figure>\n<p>将当前用户添加到docker用户组：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> groupadd docker <span class=\"comment\"># 若尚不存在 docker 组，则需先创建</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> usermod -aG docker <span class=\"variable\">$USER</span></span><br></pre></td></tr></table></figure>\n<p>由于是通过容器部署服务，环境处于“隔离”状态，<code>nginx</code>无需下载安装，可通过镜像运行于容器中。</p>\n<h3 id=\"主页测试部署\"><a class=\"markdownIt-Anchor\" href=\"#主页测试部署\"></a> 主页测试部署</h3>\n<p>首先挑选一个能够使用docker部署的web主页，这里我们以<a href=\"https://github.com/kasuie/remio-home\">remio-home | kasuie</a>为例。根据文档进行配置与部署，部署完成后访问对应端口，观察配置是否生效。</p>\n<p>按照主题文档配置完<code>docker-compose.yml</code>后，将宿主机的端口改为80（http默认端口），<code>docker-compose down &amp;&amp; docker-compose up -d</code> 或 <code>docker-compose restart</code> 重启服务，通过外网设备进行访问，正常情况下和本地访问结果无异。也可通过端口转发在本地主机进行测试访问，具体这里不展开。</p>\n<p>在通过外网设备进行访问时，若先前配置了DNS云解析，可通过域名进行访问。</p>\n<h2 id=\"静态网页资源测试\"><a class=\"markdownIt-Anchor\" href=\"#静态网页资源测试\"></a> 静态网页资源测试</h2>\n<h3 id=\"hexo基础使用\"><a class=\"markdownIt-Anchor\" href=\"#hexo基础使用\"></a> hexo基础使用</h3>\n<p>互联网中有着数不胜数的静态网页生成工具，这里我们使用<a href=\"https://hexo.io/zh-cn/\">hexo</a>。</p>\n<p>首先进入<a href=\"https://hexo.io/themes/\">主题选择页</a>选择几个心仪的主题，随后根据主题文档和官方文档构建静态站点目录和安装依赖。然后还是各个配置文件的修改与测试，这个过程相对枯燥且繁琐。</p>\n<p>需要注意的是，有些主题在后面的部署过程中可能会出现各种各样的兼容性问题，遇到无法暂时解决的，可以更换主题。</p>\n<p>配置完主题后，通过<code>hexo s</code>命令测试生成静态网页，通过浏览器访问<code>localhost:4000</code>生成网页，查看是否符合预期。确认无误后，即可进入部署阶段。</p>\n<h2 id=\"部署\"><a class=\"markdownIt-Anchor\" href=\"#部署\"></a> 部署</h2>\n<h3 id=\"github-page-用户自定义域名\"><a class=\"markdownIt-Anchor\" href=\"#github-page-用户自定义域名\"></a> Github Page + 用户自定义域名</h3>\n<p>有Github Page静态网页部署经验的同志对此应该不陌生，配合hexo的<a href=\"https://hexo.io/zh-cn/docs/one-command-deployment\">一键部署</a>使用起来方便到不能再方便了，详情这里不再展开。针对此部署方法，就算不想看官方文档，网络上也有数不胜数的教程。</p>\n<p>这种部署方法固然方便，但只能部署（.github.io）或绑定到一个域名下（custom domain），若想要通过多个二级域名来分隔部署web资源，或是将来可能需要部署其他无法通过Github Page来部署的服务（如用户登陆服务、数据库服务等），这样的方法就会极大地限制web服务的可扩展性。简单来说，是否选择该部署方法取决于部署需求，确认只有存放静态资源的需求则该方法操作便捷且功能绰绰有余。</p>\n<h3 id=\"docker-compose-nginx\"><a class=\"markdownIt-Anchor\" href=\"#docker-compose-nginx\"></a> docker-compose + nginx</h3>\n<p>废话说了这么多，接下来正片开始。</p>\n<p>在现代 web 开发中，使用 Nginx 代理不同的子域名到相应的 web 项目是一个常见的需求。同时，为了使我们的web服务能够与使用docker容器部署的主页处于同一个服务端口上，我们就需要把处于不同容器的web服务通过docker-compose合成为一个，并映射到宿主机的80端口上以供外界访问。</p>\n<p>看上去很复杂，但事实上，由于我们并不需要了解容器内的服务具体在做些什么，理论上，我们只需要简单了解docker的工作原理以及<code>docker-compose.yml</code>和<code>nginx.conf</code>的配置规则即可实现前文提到的<strong>一键部署</strong>。</p>\n<p>当然，缺点也很明显：根域名（主页）和各二级域名（web服务）均需要通过nginx进行转发，且“处于一条绳上”，一旦nginx的配置或是其本身出现问题，所有写在配置里的服务就直接给一锅端了。</p>\n<p><s>当然这也契合部分人开（摸）发（鱼）习惯，很喜欢容器化开发者中流传的一句话：“我就喜欢配一天环境啥也不干的感觉☝🤓”</s></p>\n<p>两个配置文件的编写上，如果是单纯的多个二级域名的配置，网络上的教程一抓一大把，但我们的这个项目的难点就在于此，因为我们还要把先前就已成功部署的主页服务也融合进来，如何正确将它们配置到同一个端口上对于不熟悉docker和第一次接触nginx的人算的上是个挑战（比如我）。</p>\n<p>然而经过一段时间的尝试（AI+），我们就能发现这并非什么难事：</p>\n<h4 id=\"docker配置\"><a class=\"markdownIt-Anchor\" href=\"#docker配置\"></a> docker配置</h4>\n<p>以下配置模板仅供参考</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;3.8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">remio-home:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">kasuie/remio-home</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">remio-home</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8080:3000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">GTMID=.....</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">PASSWORD=.....</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">AMAP_KEY=.....</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./remio-home/config:/remio-home/config</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./remio-home/icons:/remio-home/public/icons</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./remio-home/fonts:/remio-home/public/fonts</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">nginx:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">nginx</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;80:80&quot;</span></span><br><span class=\"line\">      <span class=\"comment\"># - &quot;443:443&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./nginx/conf.d/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./nginx/log:/var/log/nginx</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./certbot/www:/usr/share/certbot/www:ro</span></span><br><span class=\"line\">      <span class=\"comment\"># - ./certbot/ssl:/etc/letsencrypt:ro</span></span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">subsite1</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">subsite2</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">subsite3</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span>  <span class=\"string\">nginx</span> <span class=\"string\">-g</span> <span class=\"string\">&#x27;daemon off;&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># certbot:</span></span><br><span class=\"line\">  <span class=\"comment\">#   container_name: certbot</span></span><br><span class=\"line\">  <span class=\"comment\">#   image: certbot/certbot</span></span><br><span class=\"line\">  <span class=\"comment\">#   volumes:</span></span><br><span class=\"line\">  <span class=\"comment\">#     - ./certbot/www:/usr/share/certbot/www:rw #http验证目录，可设置rw可写，与nginx容器对应的宿主机目录时一致的</span></span><br><span class=\"line\">  <span class=\"comment\">#     - ./certbot/ssl:/etc/letsencrypt:rw #证书位置，同上，注意不要只映射到live，而是它的上一级</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">subsite1:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">subsite1</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sub-sites/subsite1/public:/usr/share/nginx/html</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">subsite2:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">subsite2</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sub-sites/subsite2/public:/usr/share/nginx/html</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">subsite3:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">nginx:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">subsite3</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sub-sites/subsite3/public:/usr/share/nginx/html</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">web_network:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>docker配置的关键在于<code>volumes</code>，即<strong>挂载卷</strong>的路径配置。</p>\n<p>在nginx附属服务（二级域名）的配置中，挂载卷参数的<code>:</code>前填入的是需要挂载的宿主机路径，<code>:</code>后是容器内的映射路径。这里我们需要挂载的路径是各个二级域名下需要“展示”的<strong>前端文件</strong>，即前文中提到的由静态网页生成工具生成的<strong>静态资源</strong>。</p>\n<p>在hexo中，我们通常使用命令<code>hexo cl &amp;&amp; hexo g</code>清理旧版本的静态文件并生成新版，生成的静态文件默认处于各项目根目录的<code>public</code>路径下。</p>\n<p>静态资源的整理可在任意主机上进行，部署时只需确保由静态网页生成的静态资源处于服务器上并挂载到容器的正确路径下即可。通常情况下，为确保隐私安全，静态文件的整理工作我们一般在本地主机上进行。在后续的章节中我们会介绍如何通过配置Github Action实现使静态文件从本地自动化部署至服务器上。</p>\n<h4 id=\"nginx配置\"><a class=\"markdownIt-Anchor\" href=\"#nginx配置\"></a> nginx配置</h4>\n<p><code>nginx.conf</code>的配置是该项目的核心，若出现错误导致部署无法进行，70%的问题出在nginx上，而nginx的问题有80%出在配置上（数据是瞎编的😋，但问题是真的）。</p>\n<p>以下是<code>nginx.conf</code>的参考配置，受限于篇幅，只列举主页及其中的一个二级域名的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">events &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    ; server &#123;</span><br><span class=\"line\">    ;     listen 80;</span><br><span class=\"line\">    ;     # listen [::]:80;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     server_name  virtualguard101.xyz;#域名</span><br><span class=\"line\">    ;     server_tokens off;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     #配置http验证可访问</span><br><span class=\"line\">    ;     location /.well-known/acme-challenge/ &#123;</span><br><span class=\"line\">    ;         #此目录都是nginx容器内的目录，对应宿主机volumes中的http验证目录，而宿主机的又与certbot容器中命令--webroot-path指定目录一致，从而就整个串起来了，解决了http验证问题</span><br><span class=\"line\">    ;         root /usr/share/certbot/www;</span><br><span class=\"line\">    ;     &#125;</span><br><span class=\"line\">    ;     #http跳转到https</span><br><span class=\"line\">    ;     location / &#123;</span><br><span class=\"line\">    ;         return 301 https://$host$request_uri;</span><br><span class=\"line\">    ;     &#125;</span><br><span class=\"line\">    ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name virtualguard101.xyz;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://remio-home:3000;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">        &#125;       </span><br><span class=\"line\">        # 强制HTTPS重定向</span><br><span class=\"line\">        # return 301 https://$host$request_uri;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ; server &#123;</span><br><span class=\"line\">    ;     listen 443 ssl http2;</span><br><span class=\"line\">    ;     server_name virtualguard101.xyz;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     ssl_certificate /etc/letsencrypt/live/virtualguard101.xyz/fullchain.pem;</span><br><span class=\"line\">    ;     ssl_certificate_key /etc/letsencrypt/live/virtualguard101.xyz/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     location / &#123;</span><br><span class=\"line\">    ;         proxy_pass http://remio-home:3000;</span><br><span class=\"line\">    ;         proxy_set_header Host $host;</span><br><span class=\"line\">    ;         proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">    ;         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    ;         proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">    ;     &#125;</span><br><span class=\"line\">    ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    ; server &#123;</span><br><span class=\"line\">    ;     listen 80;</span><br><span class=\"line\">    ;     # listen [::]:80;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     server_name  projects.virtualguard101.xyz;#域名</span><br><span class=\"line\">    ;     server_tokens off;</span><br><span class=\"line\"></span><br><span class=\"line\">    ;     #配置http验证可访问</span><br><span class=\"line\">    ;     location /.well-known/acme-challenge/ &#123;</span><br><span class=\"line\">    ;         #此目录都是nginx容器内的目录，对应宿主机volumes中的http验证目录，而宿主机的又与certbot容器中命令--webroot-path指定目录一致，从而就整个串起来了，解决了http验证问题</span><br><span class=\"line\">    ;         root /usr/share/certbot/www;</span><br><span class=\"line\">    ;     &#125;</span><br><span class=\"line\">    ;     #http跳转到https</span><br><span class=\"line\">    ;     location / &#123;</span><br><span class=\"line\">    ;         return 301 https://$host$request_uri;</span><br><span class=\"line\">    ;     &#125;</span><br><span class=\"line\">    ; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\"></span><br><span class=\"line\">        server_name projects.virtualguard101.xyz;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            proxy_pass http://projects:80;</span><br><span class=\"line\">            proxy_set_header Host $host;</span><br><span class=\"line\">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # return 301 https://$host$request_uri;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ;   server &#123;</span><br><span class=\"line\">  ;       listen 443 ssl http2;</span><br><span class=\"line\">  ;       server_name projects.virtualguard101.xyz;</span><br><span class=\"line\"></span><br><span class=\"line\">  ;       ssl_certificate /etc/letsencrypt/live/projects.virtualguard101.xyz/fullchain.pem;</span><br><span class=\"line\">  ;       ssl_certificate_key /etc/letsencrypt/live/projects.virtualguard101.xyz/privkey.pem;</span><br><span class=\"line\"></span><br><span class=\"line\">  ;       location / &#123;</span><br><span class=\"line\">  ;           proxy_pass http://projects:80;</span><br><span class=\"line\">  ;           proxy_set_header Host $host;</span><br><span class=\"line\">  ;           proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">  ;           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">  ;           proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class=\"line\">  ;       &#125;</span><br><span class=\"line\">  ;   &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>nginx配置的关键在于反向代理转发的配置，这是nginx一个十分重要的特性，利用它能够实现nginx中许多核心功能，如负载均衡、websocket代理等。对于我们目前的项目需求，暂时无需使用到这些较为复杂的功能，我们现在只需弄明白参数<code>proxy_pass</code>具体是做什么的，以及其最为基础的配置规则，剩下的交给cv大法即可。</p>\n<p>在nginx配置中，<code>proxy_pass</code>用于将客户端的请求代理到指定的后段服务器，简单理解就是把请求作了一次转发。其基础语法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /path/ &#123;</span><br><span class=\"line\">    proxy_pass http://backend_server:port;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该配置会将客户端上的请求转发至运行在<code>port</code>端口上名为<code>backend_server</code>的服务。结合上面的配置模板进行理解，我们可以发现主页服务在前面的docker配置中我们“恰好”将其配置在了容器的<code>3000</code>端口上，而其他的二级域名（nginx服务）我们均将其配置在了容器的<code>80</code>端口上，那么在外网设备（客户端）通过域名访问对应服务时，nginx就会将访问请求转发到对应的端口上。</p>\n<p>那么nginx怎么知道客户发送了访问请求？这就是<strong>监听</strong>要做的事。http服务默认通过<code>80</code>端口访问，通过配置<code>listen</code>参数我们可以使nginx服务监听<code>80</code>端口，就像饭点食堂阿姨站在特定窗口等着你去打饭一样。</p>\n<p>配置模板中注释掉的模块是https的配置，由于我们还未申请ssl证书，现在只能先使用http。关于ssl证书的申请我们也会在后续的章节介绍。</p>\n<p>docker 与 nginx的配置完成后，我们便可通过<code>docker-compose up -d</code>命令进行服务部署，此时正常情况下网页已经可以通过外网设备访问。若出现问题，一般情况下会反映在各个服务容器上，可通过<code>docker-compose logs</code>命令查看日志信息。</p>\n<h2 id=\"github-action自动化部署\"><a class=\"markdownIt-Anchor\" href=\"#github-action自动化部署\"></a> Github Action自动化部署</h2>\n<p><s>作为一个懒人</s>为了提高效率，写个自动化配置把部署的工作交给计算机来做自然是个不错的方法。Github Action为我们提供了一个简单的自动化构建平台，通过模块化的配置和与git远程仓库结合的管理方式极大简化了配置难度，同时集成了版本控制。</p>\n<p>Github Action自动化的配置通常位于子站点项目根目录的<code>.github/workflows</code>下。由于自动化部署的方式多种多样，配置自然也同理，故以下配置模板仅供参考。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">Subsite</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">on:</span></span><br><span class=\"line\">  <span class=\"attr\">push:</span></span><br><span class=\"line\">    <span class=\"attr\">branches:</span> [<span class=\"string\">main</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">jobs:</span></span><br><span class=\"line\">  <span class=\"attr\">hexo-build:</span></span><br><span class=\"line\">    <span class=\"attr\">runs-on:</span> <span class=\"string\">ubuntu-latest</span></span><br><span class=\"line\">    <span class=\"attr\">steps:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Checkout</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/checkout@v4</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Setup</span> <span class=\"string\">Node</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">actions/setup-node@v3</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">node-version:</span> <span class=\"number\">18</span></span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Install</span> <span class=\"string\">Dependencies</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">          npm install -g hexo-cli</span></span><br><span class=\"line\"><span class=\"string\">          npm install</span></span><br><span class=\"line\"><span class=\"string\"></span>        </span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Build</span> <span class=\"string\">Site</span></span><br><span class=\"line\">        <span class=\"attr\">run:</span> <span class=\"string\">hexo</span> <span class=\"string\">clean</span> <span class=\"string\">&amp;&amp;</span> <span class=\"string\">hexo</span> <span class=\"string\">generate</span></span><br><span class=\"line\">        </span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">Deploy</span> <span class=\"string\">to</span> <span class=\"string\">Server</span></span><br><span class=\"line\">        <span class=\"attr\">uses:</span> <span class=\"string\">appleboy/scp-action@v0.1.7</span></span><br><span class=\"line\">        <span class=\"attr\">with:</span></span><br><span class=\"line\">          <span class=\"attr\">host:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.SERVER_IP</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">username:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.SERVER_USER</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">key:</span> <span class=\"string\">$&#123;&#123;</span> <span class=\"string\">secrets.SSH_KEY</span> <span class=\"string\">&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">source:</span> <span class=\"string\">&quot;public/*&quot;</span></span><br><span class=\"line\">          <span class=\"attr\">target:</span> <span class=\"string\">&quot;/home/&lt;user&gt;/sub-sites/&lt;subsites_dir&gt;/&quot;</span></span><br><span class=\"line\">          </span><br><span class=\"line\">      <span class=\"comment\"># - name: Refresh Nginx</span></span><br><span class=\"line\">      <span class=\"comment\">#   uses: appleboy/ssh-action@v1.0.0</span></span><br><span class=\"line\">      <span class=\"comment\">#   with:</span></span><br><span class=\"line\">      <span class=\"comment\">#     host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">#     username: $&#123;&#123; secrets.SERVER_USER &#125;&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">#     key: $&#123;&#123; secrets.SSH_KEY &#125;&#125;</span></span><br><span class=\"line\">      <span class=\"comment\">#     script: |</span></span><br><span class=\"line\">      <span class=\"comment\">#       docker exec nginx_main nginx -s reload</span></span><br></pre></td></tr></table></figure>\n<p>配置模板中，<code>Deploy to Server</code>模块是配置中较为核心的模块。该模块利用<strong>scp</strong>工具将生成的静态文件传送至站点服务器的指定路径下，其中的以<code>secrets</code>开头的三个变量分别是服务器的ip地址、用户与ssh私钥，通过仓库的<code>settings</code> &gt;&gt; <code>secrets and variables</code> &gt;&gt; <code>actions</code> 配置。<br />\nssh私钥需在服务器上生成。</p>\n<p>通过上述自动化配置，在每次我们将本地仓库的更改推送至远程仓库时，github会自动在后台使用hexo生成静态文件，并通过scp将其发送至服务器的指定路径下。</p>\n<p>至此，我们仅需在本地的各个站点项目路径下修改配置或撰写文章，并将更改推送至github远程仓库，即可实现站点资源的自动化部署。</p>\n<h2 id=\"ssl认证与https模块配置可选\"><a class=\"markdownIt-Anchor\" href=\"#ssl认证与https模块配置可选\"></a> ssl认证与https模块配置（可选）</h2>\n<p>经过上面五节的配置工作，我们的站点的雏形已经完成，接下来就是最后的收尾工作。关于ssl证书与https，尽管我们并不认为它是一个网页的必要组成部分，但我们还是强烈建议为自己的站点配置ssl证书与https模块以增强安全性与可扩展性。得益于<a href=\"https://certbot.eff.org/\">certbot</a>的ssl证书免费申请功能，我们已经能够较为容易地完成这项工作。</p>\n<h3 id=\"首次申请ssl证书\"><a class=\"markdownIt-Anchor\" href=\"#首次申请ssl证书\"></a> 首次申请ssl证书</h3>\n<p>由于在该项目中，我们所有的服务均配置于docker容器中，因此我们同样需要将certbot的服务功能配置进docker-compose.yml中以实现后续的ssl证书自动化续签。事实上，certbot官方是不建议使用docker作为certbot的服务载体的，详情可参考<a href=\"https://eff-certbot.readthedocs.io/en/stable/install.html#alternative-1-docker\">Get Certbot with Docker</a></p>\n<p>在配置前，首先需要拉取certbot的docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull certbot/certbot</span><br></pre></td></tr></table></figure>\n<p>随后将前文中<code>docker-compose.yml</code>中<code>certbot</code>模块的注释去掉，并将nginx挂载卷中有关certbot的路径的注释去掉。启动服务，并通过以下命令进行测试申请：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># --dry-run是只测试不实际生成; --webroot-path对应着certbot内的http验证目录;-d后面是域名;--rm是运行后接着删除，certbot容器不需要一直开启，只是启动下生成证书即可</span></span><br><span class=\"line\">docker compose run --<span class=\"built_in\">rm</span>  certbot certonly --webroot --webroot-path /usr/share/certbot/www/ --dry-run -d [your_domain]</span><br></pre></td></tr></table></figure>\n<p>按照提示输入邮箱信息，若返回结果<code>The dry run was successful</code>，则说明测试成功，即可将<code>--dry-run</code>去掉以进行实际的证书获取：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker compose run --<span class=\"built_in\">rm</span>  certbot certonly --webroot --webroot-path /usr/share/certbot/www/ -d [your_domain]</span><br></pre></td></tr></table></figure>\n<p>申请成功后，可通过以下命令查看所有已申请的证书：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker compose run --<span class=\"built_in\">rm</span> certbot certificats</span><br></pre></td></tr></table></figure>\n<p>确认证书信息无误后即可开始nginx<code>https</code>模块的配置。与<code>docker-compose.yml</code>类似，将<code>nginx.conf</code>配置模板中https模块的注释去掉，同时将原来未注释的http模块注释掉，<code>docker-compose down &amp;&amp; docker-compose up -d</code>重启服务。完成后通过外网设备访问网页，正常情况下，网址栏会显示该网页是安全的。</p>\n<h3 id=\"ssl证书自动化续签\"><a class=\"markdownIt-Anchor\" href=\"#ssl证书自动化续签\"></a> ssl证书自动化续签</h3>\n<p>使用certbot一个很大的原因就是因为其可通过配置<strong>定时任务</strong>进行ssl证书的自动化续签。具体配置十分简单，一个bash的问题：</p>\n<p>创建bash脚本，并写入定时申请命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vim sslrenew.sh   <span class=\"comment\"># 创建脚本文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写入命令</span></span><br><span class=\"line\">docker compose run certbot renew</span><br></pre></td></tr></table></figure>\n<p><code>crontab -e</code>添加定时任务，每个月第一天凌晨四点执行，也可根据自己情况进行配置：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 4 1 * * ~/sslrenew.sh</span><br></pre></td></tr></table></figure>\n<p>配置完成后，可通过<code>crontab -l</code>命令查看配置的定时命令，确认配置是否写入。</p>\n<p><strong>BASE END</strong></p>\n<p>到此为止，所有的基础配置也就完成了。此时我们的个人站点已经可以被世界上所有接入互联网的设备访问了，同时我们也可根据个人需求为站点添加各种各样的功能与服务。</p>\n<p>主要参考文献：</p>\n<ul>\n<li><a href=\"https://cloud.tsyidc.com/web/822.html\">docker部署nginx多级子域名 | 蓝易云</a></li>\n<li><a href=\"https://www.cnblogs.com/vishun/p/15746849.html\">docker部署certbot与nginx来获取ssl证书添加https及自动更新 | vishun</a></li>\n<li><a href=\"https://kasuie.cc/article/22\">使用Certbot自签SSL证书 | kasuie</a></li>\n</ul>\n<hr />\n<h2 id=\"增添服务\"><a class=\"markdownIt-Anchor\" href=\"#增添服务\"></a> 增添服务</h2>\n<p>既然我们都选择了使用云服务器来构建我们的个人站点，那么仅使用它来存放静态页面显然是大材小用。对于站点功能的丰富，还是那句话，在成熟工具链丰富的现代开发环境下，并不是什么很难的事情。很多时候，我们只需要正确打开别人写好的文档即可。</p>\n<p>对于功能扩展这部分的内容，更多的还是将目光放在部署工具供应者的使用文档上，这里只基于该文介绍的站点部署方法简单介绍一下我个人摸索出的<strong>标准化部署流程</strong>以及部署过程中可能碰到的<strong>问题</strong>。</p>\n<h3 id=\"标准化部署流程\"><a class=\"markdownIt-Anchor\" href=\"#标准化部署流程\"></a> 标准化部署流程</h3>\n<p>以下流程为个人在实际部署过程中摸索出的不同服务部署过程的共通点，仅供参考。</p>\n<p>现在，假设我们想要在服务器上部署一个AI对话服务，那么我们便可遵循以下流程进行服务的配置及部署：</p>\n<h4 id=\"一-工具链选取及基础配置工作\"><a class=\"markdownIt-Anchor\" href=\"#一-工具链选取及基础配置工作\"></a> 一、工具链选取及基础配置工作</h4>\n<ul>\n<li><strong>0. 选取对应的服务部署工具链，查阅官方文档并结合当前环境分析部署可行性。</strong></li>\n</ul>\n<p>我们想要在服务器上部署一个AI对话服务，那么结合当前部署环境，我们就应该在网络上查找对应的<code>docker</code>镜像（image）。这里我们使用<a href=\"https://github.com/SillyTavern/SillyTavern\">LLM Frontend | SillyTavern</a>进行部署。</p>\n<p>该框架具有docker镜像，且支持使用docker-compose部署，符合当前的环境要求，且部署难度和成本相对较低。</p>\n<ul>\n<li><strong>1. 拉取docker镜像（可跳过）</strong></li>\n</ul>\n<p>执行以下命令以获取待部署的docker镜像：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/sillytavern/sillytavern:latest</span><br></pre></td></tr></table></figure>\n<p>在使用docker-compose进行部署时，若<code>docker-compose.yml</code>配置无误，镜像会自动拉取。执行这一步主要是为了提前判定镜像是否处于可获取的状态。</p>\n<ul>\n<li><strong>2. 根据工具文档及个人需求进行配置文件的配置或修改</strong></li>\n</ul>\n<p>项目主页：<a href=\"https://sillytavern.app/\">SillyTavern - LLM Frontend for Power User</a><br />\n项目仓库：<a href=\"https://github.com/SillyTavern/SillyTavern\">SillyTavern</a></p>\n<h4 id=\"二-docker-composeyml配置\"><a class=\"markdownIt-Anchor\" href=\"#二-docker-composeyml配置\"></a> 二、docker-compose.yml配置</h4>\n<p>由于docker的容器环境是我们站点的部署基础，这部分的配置便显得尤为重要。可参考以下步骤进行配置：</p>\n<ul>\n<li><strong>1. 依照文档给出的配置框架结合部署环境进行基础配置</strong></li>\n</ul>\n<p>官方给出的<code>docker-compose.yml</code>如下：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">sillytavern:</span></span><br><span class=\"line\">    <span class=\"attr\">build:</span> <span class=\"string\">..</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">sillytavern</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">sillytavern</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">ghcr.io/sillytavern/sillytavern:latest</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">NODE_ENV=production</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">FORCE_COLOR=1</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;8000:8000&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;./config:/home/node/app/config&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;./data:/home/node/app/data&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;./plugins:/home/node/app/plugins&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;./extensions:/home/node/app/public/scripts/extensions/third-party&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br></pre></td></tr></table></figure>\n<p>我们可结合部署环境与部署需求对<code>environment</code>、<code>volumes</code>、<code>port</code>中的值进行修改，同时还需注意<code>docker-compose.yml</code>与服务自身配置（<code>config.yaml</code>）的对应关系。比如，针对<code>port</code>参数，<code>config.yaml</code>中默认将服务映射在<code>8000</code>端口上，若两个配置不对应，在访问时就会遇到<code>502(Bad Gateway)</code>错误。</p>\n<p>还有一点需要注意：由于nginx服务也运行于容器中，故在此项目的实际配置与部署过程中，真正有效的端口参数是<code>port</code>参数的<strong>容器服务端口</strong>。</p>\n<ul>\n<li><strong>2. 网络关系配置</strong></li>\n</ul>\n<p>容器化技术的一大亮点在于不同服务容器环境相互独立的情况下也可通过形形色色的配置建立起各个容器间的联系。配置这些东西过程被厌恶容器技术的人所诟病，这些人认为该过程徒增工作复杂度，殊不知这是被他们所忽略的本职工作。</p>\n<p>服务间网络关系的配置也是上述关系配置中的一环，通过前文的配置我们知道，各个服务的网络配置通过<code>networks</code>参数控制，而在该项目中我们统一使用<code>web_network</code>作为各个服务的网络配置参数。故在官方文档原有框架的基础上，我们需要为模块追加如下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">web_network</span></span><br></pre></td></tr></table></figure>\n<!-- 否则会导致sillytavern容器未连接到web_network网络，出现容器错误 -->\n<ul>\n<li><strong>3. 服务依赖关系</strong></li>\n</ul>\n<p>和网络关系相比，不同服务的依赖关系在体现各个服务容器之间的联系上更加直接。</p>\n<p>在本项目中，由于需要使用nginx对各个服务进行转发，依赖关系便体现在各个部署在二级域名上的服务与nginx服务上。完成<code>sillytavern</code>服务的配置后，我们需要在nginx模块的<code>depend_on</code>参数追加如下配置：</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">depend_on:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">.....</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">sillytavern</span></span><br></pre></td></tr></table></figure>\n<!--显式声明容器依赖关系，确保sillytavern先于nginx启动，否则会出现nginx容器错误 -->\n<h4 id=\"三-nginx-https模块配置\"><a class=\"markdownIt-Anchor\" href=\"#三-nginx-https模块配置\"></a> 三、nginx-https模块配置</h4>\n<ul>\n<li><strong>1. 反向代理基础配置（http模块）</strong></li>\n</ul>\n<p>依照前文基础配置的<code>nginx.conf</code>模板进行修改即可。</p>\n<ul>\n<li><strong>2. ssl证书申请及https模块配置</strong></li>\n</ul>\n<p>遵循<code>复制模板</code>-<code>注释</code>-<code>解除注释</code>-<code>申请</code>-<code>解除注释</code>的“五步原则”。注释及解除注释操作的对应模块如下：</p>\n<p><strong>注释</strong>：注释<strong>http反向代理模块</strong><br />\n<strong>第一次解除注释</strong>：解除<strong>http ACME验证挑战模块</strong>注释<br />\n<strong>第二次解除注释</strong>：解除<strong>https反向代理模块</strong>注释</p>\n<hr />\n<p>完成以上三大步，8小步的配置与部署操作，部署工作基本也就完成了。</p>\n<h2 id=\"常见问题\"><a class=\"markdownIt-Anchor\" href=\"#常见问题\"></a> 常见问题</h2>\n<p>部署过程中经常会碰到一些奇奇怪怪的问题，特别是不熟悉docker、nginx配置规则的初学者。下面是我在部署过程中遇到的问题的汇总。</p>\n<h3 id=\"nginx错误-服务访问错误\"><a class=\"markdownIt-Anchor\" href=\"#nginx错误-服务访问错误\"></a> nginx错误、服务访问错误</h3>\n<p>通常表现为nginx容器无法正常运行，网页访问<code>500</code>、网页访问<code>502</code>等，具体原因可能有如下几种：</p>\n<ul>\n<li><code>nginx.conf</code>配置错误</li>\n</ul>\n<p>通常是反向代理模块中<code>proxy_pass</code>参数的配置有误，比如后端服务的<strong>端口</strong>或<strong>服务名称</strong>与<code>docker-compose.yml</code>中配置的不对应。</p>\n<ul>\n<li><code>docker-compose.yml</code>配置错误</li>\n</ul>\n<p>通常是前文提到的不同容器间关系的配置有误或者缺失，特别是nginx服务与其他需要通过nginx服务进行转发的服务之间的关系。如<code>networks</code>配置、容器依赖关系配置；以及前文提到的服务配置与docker-compose配置的对应关系问题，如服务端口的对应问题。</p>\n<h3 id=\"ssl证书申请certbot错误\"><a class=\"markdownIt-Anchor\" href=\"#ssl证书申请certbot错误\"></a> ssl证书申请（certbot）错误</h3>\n<p>通常表现为无法申请ssl证书、申请证书后访问显示“<s>https</s>网页不安全”等，具体原因可能有如下几种：</p>\n<ul>\n<li>无法申请ssl证书（certbot无法正常运行）</li>\n</ul>\n<p><strong>1. 同一域名在短时间内申请次数过多</strong></p>\n<p><strong>2. <code>nginx.conf</code>中http ACME验证挑战模块配置有误</strong></p>\n<p><strong>3. 在特殊环境（如需要进行用户验证）下未注释http反向代理模块导致无法访问服务的问题（如<code>401</code>）</strong></p>\n<p><strong>4. 域名本身无法正常访问（<code>5xx</code>、<code>4xx</code>）</strong></p>\n<ul>\n<li>访问问题（提示网站不安全）</li>\n</ul>\n<p><strong>1. 申请ssl证书时信息有误，如二级域名名称错误</strong></p>\n<p><strong>2. <code>nginx.conf</code>中https模块二级域名（server_name）配置有误</strong></p>\n<p><strong>3. <code>nginx.conf</code>中https模块证书路径有误</strong></p>\n<p>关键在与证书与域名的对应关系是否有误。</p>\n<hr />\n<p><strong>END</strong></p>\n",
            "tags": [
                "web开发",
                "docker"
            ]
        }
    ]
}