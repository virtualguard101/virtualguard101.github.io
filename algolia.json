
[
  
  
  {
    "objectID": "1744535233",
    "permalink": "/post/resource/engineered/",
    "title": "工程类资源",
    
    "content": " 教程 文档 博客 ",
    
    "date": "2025-04-13 17:07:13",
    "updated": "2025-04-13 17:07:13"
  }
  
  , 
  {
    "objectID": "1744535118",
    "permalink": "/post/resource/academic/",
    "title": "理论类资源",
    
    "content": " Note：本页面的食用方式如下：\n1.课程模块主要由教材（电子书/网页文档）、幻灯片、课程主页（网址）、csdiy课程信息页、课程录播视频五个要素组成，由于不同课程的差异以及资源碎片化的特性，上述五个要素一般不会同时出现，当然，也有可能你可以在一个汇总性的要素中找到其他的要素。各个要素会按照我个人认为的权重进行排序。例如，在CS61A中，精读课程的部分内容对我来说是合理的，那么我便将课程主页、csdiy课程信息页这类汇总性较强的要素排在前面；而对于CS106L而言，仅仅需要阅读课程教材及幻灯片就能很大程度上掌握课程的主要内容，以及当下我只希望快速通读一下这个课程的主要内容，那么我就将教材与幻灯片置前。\n2.进阶理论：大部分进阶理论不是处于技术闭源的状态就是只能通过原始学术论文了解，该模块的内容除去部分科普性的资料，大部分是晦涩难懂的。但可以肯定的是，所有的进阶理论都有它们对应的基础依赖。\n编程入门 课程 MIT-missing-semester: The Missing Semester of Your CS Education 课程简述：课程主要传授在大学课堂上几乎不会涉及但对于cs学习无比重要的工具或零散知识点。例如shell、Git（版本控制）等\n课程网址/教程：The Missing Semester of Your CS Education\n课程中文网址/教程：计算机教育中缺失的一课\ncsdiy课程信息页：MIT-Missing-Semester | csdiy\npass\nCS61A: Structure and Interpretation of Computer Programs 课程简述：伯克利CS61系列的第一门课程，使用python作为课程的编程语言。强调抽象，让学生掌握用程序来解决实际问题，而不关注底层的硬件细节。oop（面向对象编程）入门利器。\n课程官方网址：CS61A | UC Berkeley\n往期课程页面备份：Fall 2024 | hqhq1025\n课程教材：Composing Programs\n课程教材中译：COMPOSING PROGRAMS\ncsdiy课程信息页：CS61A: Structure and Interpretation of Computer Programs | csdiy\nhalf pass 【py-oop】\npass 【Functional Programming】【SQL】\nC++ Tutorial - w3school 课程简述：这个就没什么好说的了，就是单纯的文档型教程，与国内的菜鸟教程类似，但在重点讲解上显然要精简得多。对C++的各种特性毫无概念时可以参考这个教程，可以在短时间内建立起对C++的初步了解，随后即可通过CS106L深入了解C++的各种特性及其运用。\n课程网址：C++ Tutorial | w3school\npass\nCS106L: Standard C++ Programming 课程简述：这门课会深入到很多标准 C++ 的特性和语法，让你编写出高质量的 C++ 代码。例如 auto binding, uniform initialization, lambda function, move semantics，RAII 等技巧。这门课并不难，但是信息量很大，需要在之后的开发实践中反复巩固，因此正好适合正在钻研C++工程的我。\n官方教材：CS106L-Textbook\n课程资料备份1（幻灯片等）：Winter 2024 | JiNanPiWang\n课程资料备份2：Winter 2025 | Gkbinqi\ncsdiy课程信息页：CS106L: Standard C++ Programming | csdiy\n课程官方网址：CS106L: Standard C++ Programming | Stanford University\npass\n进阶理论 GPU工作原理 模块简述：GPU是现代计算机上一个重要的处理模块，主要用于诸如图形学计算、深度学习等对并行计算性能要求较高的计算领域。需要注意的是，GPU与人们口中常说的显卡是两个概念，前者是一个处理芯片，后者是一个完整、独立的计算机部件。\n基础依赖：计算机体系结构、计算机组成原理\n相关文章1：计算机组成原理——GPU图像处理器 | 云物互联\n相关视频1：内存与显存的区别 | Redknot-乔红\nNote：该视频内容主要介绍了GPU数据传输技术、显存（GDDR：Graphics Doule Data Rate SDRAM，图形双倍数据速率同步动态随机存取储存器）技术与传统内存（DDR：Doule Data Rate SDRAM，双倍数据速率同步动态随机存取储存器）技术的区别\n",
    
    "date": "2025-04-13 17:05:18",
    "updated": "2025-04-16 17:05:18"
  }
  
  , 
  {
    "objectID": "1742256000",
    "permalink": "/post/projects/fpga_gpu/gpu_researching-log/",
    "title": "基于FPGA的图形加速器实现：FPGA-GPU项目日志",
    
    "content": " 导言 在互联网上，我们能够找到数不胜数的有关手搓CPU的项目资料，甚至有大佬为此出版专门的教程，但很少能够看到有关GPU的资料。\n本次项目旨在通过参考网上上少有的资料，基于FPGA（现场可编程门阵列）实现一个寄存器传输级（RTL）的图形加速器，即显卡或GPU（Graphics Processing Unit）。当然，商业级的显卡与单纯的GPU芯片并不是同一个概念，我们的目标仅仅只是设计一个能够加速图形渲染速度的IP核（Intellectual Property Core）。 项目主要分为两个阶段：模板复现与功能扩展。 在模板复现阶段，我们将根据知乎文章从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理的指导复现出其中的图形渲染场景。 Let\u0026rsquo;s begin our journey! 项目名称：FPGA-GPU\n项目成员：virtualguard_C 项目指导：vigosser_L 项目核心参考：从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理\n项目核心参考代码仓库：PainterEngine\n复现阶段 预备阶段 提出项目，验证可行性 收集相关理论资料 预备开发环境 第0周（2025.3.15-16） 2025.3.15晚: 项目指导提出项目，提供核心参考文献（以下简称原文）从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理，项目启动 2025.3.16: 第一次线下交流，确定方向\n通过直接询问核心参考文献作者（以下简称作者）及ai查询相结合的方式，解决C项目在linux系统上（Ubuntu22.04）的编译配置问题（Makefile配置），成功复现上层C语言层面的软渲染器实现。具体配置如下：\nwinodws系统配置和其他具体过程这里不再赘述，详情可参考原文，这里只说明在linux上的编译配置。\n创建独立的项目目录，并将软渲染实现的c源码从克隆或解压缩后的源项目路径复制过来：\nmkdir -p workspace cd ./workspace cp /path/to/PainterEngine/platform/fpga_gpu/simulator/* . 复制Makefile并进行修改：\ncp /path/to/PainterEngine/platform/linux/makefile . code ./makefile Makefile配置如下： - code_01\n#gcc freeglut makefile ##################################################### target :=painterEngine project_path := /path/to/workspace painterengine_path := /path/to/PainterEngine/ ##################################################### project_build := $(wildcard $(project_path)/*.c) project_build_cpp = $(wildcard $(project_path)/*.cpp) project_build_o := $(patsubst %.c,%.o,$(project_build)) project_build_o += $(patsubst %.cpp,%.o,$(project_build_cpp)) painterengine_build_core := $(wildcard $(painterengine_path)/core/*.c) painterengine_build_painterengine_o := $(patsubst %.c,%.o,$(painterengine_build_core)) painterengine_build_kernel := $(wildcard $(painterengine_path)/kernel/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_kernel)) painterengine_build_runtime := $(wildcard $(painterengine_path)/runtime/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_runtime)) painterengine_build_platform := $(wildcard $(painterengine_path)/platform/linux/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_platform)) painterengine_build_platform := $(wildcard $(painterengine_path)/platform/linux/*.cpp) painterengine_build_painterengine_o += $(patsubst %.cpp,%.o,$(painterengine_build_platform)) all:$(project_build_o) $(painterengine_build_painterengine_o) gcc $(project_build_o) $(painterengine_build_painterengine_o) \\ -o $(target) \\ -I \u0026#34;$(painterengine_path)\u0026#34; \\ -I \u0026#34;$(project_path)\u0026#34; \\ -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; \\ -I \u0026#34;$(painterengine_path)/runtime\u0026#34; \\ -L. -lGL -lglut -lpthread $(project_path)/%.o:$(project_path)/%.c gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; $(project_path)/%.o:$(project_path)/%.cpp gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; $(painterengine_path)/runtime/%.o:$(painterengine_path)/runtime/%.c gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; $(painterengine_path)/kernel/%.o:$(painterengine_path)/kernel/%.c gcc -c $^ -o $@ $(painterengine_path)/core/%.o:$(painterengine_path)/core/%.c gcc -c $^ -o $@ $(painterengine_path)/platform/linux/%.o:$(painterengine_path)/platform/linux/%.c gcc -c $^ -o $@ -I \u0026#34;$(project_path)\u0026#34; -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; clean: find $(painterengine_path) -type f -name \u0026#34;*.o\u0026#34; -exec rm -f {} + find $(painterengine_path) -type f -name \u0026#34;a.out\u0026#34; -exec rm -f {} + 相比较源项目需要正确修改项目路径和PainterEngine所在路径，这里我们还添加了make clean的配置。\n修改完成后，务必检查路径是否配置正确，随后即可开始编译：\nmake all -f ./makefile 编译完成后，运行生成于当前路径的painterEngine可执行程序，即可成功复现原文对应内容。\n第1周（2025.3.17-23） 2025.3.17 开始汇总基础依赖，收集相关理论资料 根据原文主要需要以下方面的基础知识： 1.C语言基础、verilog基础\n2.计算机组成原理/计算机系统基础\n3.计算机图形学基础\n4.数字电路基础\n5.通信原理基础\n6.FPGA设计基础\n获取FPAG编译工具Vivado与Vitis 注意版本问题，最佳版本为2024.02，过老的版本会出现无法打开原文项目的问题。\n另外需要注意的是，运行Vivado对设备硬件有一定需求，主要参考设备CPU的单核性能以及内存容量，内存最好在32G以上。同时，虽然Vivado存在linux版本，但安装过程相当繁琐，且极易出现兼容性问题，故不展开。\n在安装过程中，需要AMD的官方账号，安装时需要的地址信息可通过美国地址生成器生成。\n参考资料：\n原文评论区 - resource_01\nVivado全版本下载分享 - resource_02\nVivado安装问题（linux） - resource_03\nVivado 2018.3 下载及安装 - resource_04\n基础概念了解 这个方式多样，需要日积月累，碎片化的概念可以通过AI和浏览器查询；也可以在一些平台上阅读一些相关的文章，反向利用大数据的推送机制。\n芯片基础概念划分 - resource_05\n系统性的知识体系可以通过一些书籍和课程来学习\ncsapp：深入理解计算机系统 -resource_06\ncsapp中文讲解 - resource_07\nGPU架构开源资料（项目指导提供） tiny-gpu | github repository - resource_08\nFlexGripPlus-兼容CUDA的开源GPGPU实现简介 - resource_09\nFlexGripPlus | github repository - resource_10\n2025.3.18 初始化项目日志 是的，就是这个你正在看的玩意\n获取硬件（型号ZYNQ-xc7z020clg484-1） 硬件平台是Zynq7000系列的SoC开发板, 详情参考原文\n硬件详细资料 - resource_01\nAMD官方文档 - resource_02\n基础理论学习阶段 依据预备阶段收集到的基础依赖进行基础理论学习 进一步收集资料，同时进行消化 注：该阶段过程相对漫长，日志有概率不以逐周形式展开\n2025.3.19 准备阶段基本结束，进入基础理论学习阶段 项目复现核心概念专有名词简要解释 - resource_01\n软渲染器的c语言实现原理 可直接参考项目原文\n从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理 - resource_02\n其实就是我们在预备阶段配置的demo\n相关理论基础：C语言、计算机图形学\nGAMES101: 现代计算机图形学入门 - resource_03\n《Fundamental Of Computer Graphics 4th Edition》（计算机图形学基础） - resource_04\n《计算机图形学：原理与实践（基础版）》| 机械工业出版社 - resource_05\n2025.3.20 针对【Rs-250319】，为了节约时间，我们无需全篇通读，仅需了解与项目对应的概念。\nNote：此后本日志以{data(id)}-date形式指代对应日期（一般是首次）整理至此的参考文献、问题等资料，方便回溯。例如【Rs-250319】指2025.3.19的所有resource；【Q01-250325】指2025.3.25的question_01）\n例如，针对《计算机图形学：原理与实践（基础版）》，我们只需迅速地通读七至十五章的内容，对计算机图形学的数学原理和基础概念与实现作个快速了解即可。\n另外，由于C++面向对象的特性，图形学在编程过程中更倾向于使用C++而不是C（虽然二者在语法上差别不大），《计算机图形学：原理与实践（基础版）》中的测试实现语言也是C++，故在此整理如下参考文献：\nPython to C++ Guide | CS106B - resource_01\nC++ 教程 | 菜鸟教程 - resource_02\n2025.3.22 SoC主板上电测试成功 - image_01\n- image_02\n这里采用的是测试固件二，结果标准参考硬件详细资料 - resource_01\n上传计算机图形学材料（🐯书原版第四版 | 文件来源：z-library） 即【R04-250319】的英文原版\n《Fundamental Of Computer Graphics 4th Edition》 - resource_02\n2025.3.23 针对计算机图形学的基础概念了解基本结束 主要参考材料：【R04-250319】的第二章及第三章\n需要注意的是，计算机图形学模块并非我们项目复现阶段的主要基础依赖，对其涉猎的数学基础（重心坐标系等）及图形光栅化的概念有个初步了解即可。\n事实上，项目原文中demo的图形渲染原理并不复杂。在复现阶段，理解三角图元是如何渲染的就足够了。在原文的demo中，三角图元的构造方法使用了最为简单的重心坐标法，【R04-250319】中对此的描述严谨且复杂，但并不利于理解————事实上，仅仅通过初中的几何知识加上向量的概念就能轻易理解重心坐标的构造过程。\n上传计算机系统基础材料（《csapp：深入理解计算机系统》3rd-中译版 | 文件来源：z-library） 《深入理解计算机系统（原书第3版）》 - resource_01\n接下来即可入本项目核心基础依赖的学习：计算机系统基础\n尽管针对该基础依赖，本项目仍然只运用到其中的一小部分内容（第一章、第四章与第六章），但介于计算机系统基础在计算机学习中的重要地位，还是建议尽可能地吃透它。\n针对该基础内容，该日志的前文收录了相关的官方课程与中文讲解：\n官方课程：【R06-250317】\n中文讲解：【R07-250317】\n第二周 2025.3.24 开始学习计算机系统-处理器架构 《csapp》对应章节为第一部分第三章，当然最好还是将第一部分的所有内容都消化一遍\nY86-64架构的verilog实现 | ARCH: VLOG Verilog Implementation of a Pipelined Y86 Processor - resource_01\nVerilog 快速上手笔记 | Hello-FPGA - resource_02\n2025.3.25 参考硬件工程资料 FPGA vs ASIC - resource_01\nFPGA基础 -resource_02\nVivado2024.02工程参考 - resource_03\n另外在vivado内部也有示例工程可供参考, 在进入vivado的主页面选择Open Example Project即可\n在官方网站也有相对完善文档及交流社区（甚至还有中文社区，他真的，我哭死）：\n设计概述 | AMD技术信息门户网站 - resource_04\n电源管理 | AMD技术信息门户网站 - resource_05\n启动和配置 | AMD技术信息门户网站 - resource_06\n调试 | AMD技术信息门户网站 - resource_07\nNote：需要注意的是，中文的文档通常翻译自官方文档，因此可能存在时效性问题，最好的解决方法还是查阅官方文档。\n另外，【R01-250318】中；整理了大量教学性的工程（实验）示例供我们参考（但是开发环境的版本不同，有些地方仍需自行探索）。\n第一次【全】黑盒复现失败 在对底层原理与工程化流程均不了解的情况下，外加开发环境的版本问题，成功率自然低得可怜。用人话来说就是P都不懂就xjb乱搞😢\n第二次【全】黑盒复现失败，停止黑盒测试，转向工程化流程学习 工程化流程学习优先参考【R01-250318】\n通过工程化流程学习发现当前环境存在的致命问题 初步判定为当前环境缺少vitis硬件平台编译工具（虽然有个和vivado共存的叫“vitis”的IDE），尝试通过官方下载程序将其升级为vitis - error_01\nVitis: Installs Vitis Core Development kit for embedded software and application acceleration development on Xilins platforms. Vitis installation includes Vivado Design Suite. Users can also install Vitis lodel Composer to design for AI Engines and Programmable Logic in HATLAB and Simulink.\nVivado: Includes the full coplement of Vivado Design Suite tools for design, including C-based design with Vitis High-Level Synthesis, implementation, verification and device programming, Complete device support, cable driver, and Document Navigator included. Users can also install Vitis Model Composer to design for AI Engines and Programable Logic in HATLAB and Simulink\n参考GPU数据传输技术（DDR与GDDR） 内存与显存的区别 - resource_08\nNote：对复现阶段乃至整个项目而言，该资料的参考价值都是极高的，对其内容的理解直接影响到对复现阶段结果底层原理的理解\n2025.3.26 参考显卡/GPU工作原理及体系结构 计算机组成原理——GPU图像处理器 | 云物互联 - resource_01\nNote：相较【R08-250325】，这份资料更像是其视频内容的文本化，但对GPU的介绍更加全面，说【R08-250325】是它的子集或许更加贴切\n另外需要注意的是，虽然在大多课堂中对GPU的工作原理现有提及，但对GPU体系结构的学习建立在计算机组成原理/体系结构的基础之上\n否定【E01-250325】的初步判定 错误根源并非初步判定所述版本问题，或不止这一个问题\n【E01-250325】解决遭遇瓶颈 开展第一次线上会议，仍未解决该问题，现在此详细描述该问题：\n错误编号：E01-250325\n错误简述：在vivado工程构建完成，点击Export Hardware生成.xsa文件后，启动vitis时无Create Platform Component选项可供选择，无法将已经通过vivado完成并导出的硬件设计文件正确加载至vitis进行进一步完善并写入硬件\n错误复现：\n1.在vivado上创建并完善一个硬件设计，随后导出.xsa硬件存档\nvivado工程的创建与配置这里不再赘述，详情参考vivado 2019.2 以上带vitis 版本的简单教程演示中的第一到五步\n接下来就是问题的关键所在：\n根据上面的指导导出硬件后，整个工程的结构如下图所示\n通过Tools \u0026raquo; Launch Vitis IDE选项打开vitis，或通过点击应用快捷方式直接进入，加载后的界面如图所示\n依照官方文档、上文指导以及项目原文，在vitis的welcome界面上和file \u0026raquo; New Component选项上都应存在Create Platform Component（file \u0026raquo; New Component 是platform选项）选项可供选择，但上图所示并不存在该选项\n2025.3.27 初步解决【E01-250325】 初步解决方案：直接更换vivado版本，2024.02 -\u0026gt; 2023.02，简单粗暴\n同时注意在下载时勾选下图中箭头所指的选项\n第三次【半】黑盒复现失败 本次黑盒测试建立在对vivado/vitis项目的工程化流程有一定了解的基础之上\n失败原因：app_component模块执行built时发生致命错误，现有了解无法解决该问题\n2025.3.29 第四次【半】黑盒复现失败 尝试通过黑盒测试解决第三次复现致命错误的努力失败，黑盒测试中断，转向理论学习与工程代码解析，即黑盒白盒化\n第三周 2025.4.5 开始实行项目理论基础、计算机理论基础进度相互独立，二者并行推进 此举是为避免在项目遭遇工程或依赖理论学习瓶颈时在进度上牵制计算机基础理论学习，以及在后者遇到路线问题时牵制前者的推进。简单来说，就是实行计算机基础学习与项目探索在进度上的相互独立，但不干扰二者二者之间相辅相成、相得益彰的关系。具体落实体现即项目探索及计算机理论基础的并行推进。\n2025.4.6 项目组第二次线下交流，确定当前工程瓶颈解决方向 针对项目在工程构建上遇到的瓶颈，确认问题核心在于C/C++项目工程构建问题，可通过学习Make、Cmake的使用建立对C/C++工程构建的认识\n第四周 2025.4.13 参考make、cmake教程 Makefile Tutorial - resource_01\nCMake Tutorial - resource_02\n第五周 2025.4.14 速通C++基础、oop特性等，为工程化学习作铺垫 在有pyton面向对象编程经验的前提下，选择合适的材料能够快速掌握cpp的各种特性\nC++ Tutorial | w3school -resource_01\nCS106L | Stanford University -resource_02\n",
    
    "date": "2025-03-18 00:00:00",
    "updated": "2025-04-16 00:00:00"
  }
  
  , 
  {
    "objectID": "1742136490",
    "permalink": "/post/projects/space-calculator/py_oop/",
    "title": "多态对象共享接口：一个简易立体几何计算器的python实现",
    
    "content": " 导言 学习了cs61a的有关python面向对象的课程（函数式编程没有去细看，本文内容也与之无关），对面向对象的思想有了更加深刻的理解，特别是在多态对象的统一接口思想上，其在实现上主要运用了python对象系统的继承及组合机制（详情可以参考cs61a的课程资料）。当然，不是只有python才具有继承与组合机制，几乎所有的面向对象语言都支持继承与组合。 将上面的思想与数学中立体几何的各种定义结合起来，就有了下面这个项目👇 项目网址：Space Calculator 本文主要结合cs61a的课程思想，通过核心代码简要解读一下这个项目的实现框架，针对语法及代码细节不作展开，详情可结合本文自行阅读源码，核心代码位于项目根目录下的/src/space.py 多态对象 一个数据对象可能由不止一种有用的表示，我们也许会想要设计能够处理多种表示形式的系统。这是cs61a对多态对象系统的表述。在构建一个对象时，我们可以从多个角度来描述构建该对象所需要的属性，从而使这个对象有多种表示形态。 举一个简单的例子，一个向量在空间中的表示通常有坐标表示和**分解表示（通常是正交分解）**两种形式，前者在代数运算上具有极大的方便，后者在几何意义的表示上具有优势。因此在构造一个向量时，我们就可以通过两种方式进行构造： class VectorWithPoint(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with point.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;geometry\u0026#39; def __init__(self, point_start: Point, point_end: Point): super().__init__() self.point_s = point_start self.point_e = point_end def __repr__(self): super().__init__() return f\u0026#39;Vector({self.point_s.name}{self.point_e.name}) == {VectorWithCoordinate((self.point_e.x - self.point_s.x), (self.point_e.y - self.point_s.y), (self.point_e.z - self.point_s.z))}\u0026#39; def __str__(self): return f\u0026#39;{self.point_s.name.upper()}-\u0026gt;{self.point_e.name.upper()}\u0026#39; class VectorWithCoordinate(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with coordinate.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;algebra\u0026#39; def __init__(self, x, y, z): super().__init__() self.x = x self.y = y self.z = z def __repr__(self): return f\u0026#39;Vector({self.x}i + {self.y}j + {self.z}k)\u0026#39; def __str__(self): return f\u0026#39;({self.x}, {self.y}, {self.z})\u0026#39; 通过上面的py代码中，我们可以通过**几何元素（点）和代数元素（坐标）**两种形态来构造和表示一个向量对象，从而为我们后续的可能需要的操作作铺垫。 组合、继承与对象接口 继承与组合 继承是面向对象编程中一个强大的机制，它允许一个子类从其所继承的父类继承属性和方法。我们通过将计算结果为基类（父类）的表达式放在类名后面的括号中来指定继承。\nclass VectorOperation: \u0026#39;\u0026#39;\u0026#39;The operation interface for vector which represent with coordinate or point in space.\u0026#39;\u0026#39;\u0026#39; class VectorWithPoint(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with point.\u0026#39;\u0026#39;\u0026#39; class VectorWithCoordinate(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with coordinate.\u0026#39;\u0026#39;\u0026#39; 在上面的代码中，类VectorWithCoordinate、VectorWithPoint均继承于VectorOperation。 对于类的继承，我们通常以is-a即xx是一个xx来描述子类与父类之间的关系，从上面的例子来看就是几何形态向量与坐标形态向量都是一个向量（所以从定义角度来看，VectorOperation应该改为Vector）。\n在面向对象中，还有一个概念称为类的组合，以has-a即xx有一个xx来描述二者的关系。举一个简单的例子：\nclass Lessons: def __init__(self, name, teacher, grade): self.name = name self.teacher = teacher self.grade = grade class Students: def __init__(self, name, id): self.name = name self.id = id self.lesson = Lessons(\u0026#39;python-oop\u0026#39;, \u0026#39;cs61a\u0026#39;, 4.0) def __repr__(self): return f\u0026#39;name: {self.name} id: {self.id} \\ lesson: {self.lesson.name}\u0026#39; 在上面的代码中，我们定义了两个类：Lessons和Students，其中Students的构造函数中将Lessons的一个实例作为一个属性，用上面的关系来说明就是学生有一门课程。在面向对象编程中，组合相比起继承更加灵活，因为后者所定义的类与类之间的关系是静态的，前者反之。 在这个项目中，我们对组合的运用同样无处不在。在数学关系上，各个概念之间的关系是确定的，不需要动态调整，因此我们在这里更加倾向于使用继承来描述类于类之间的关系；而在定义操作各个数学元素的运算概念时，组合灵活的优势就能得到极大的发挥。定义运算的地方和方法就是下文将要重点介绍的对象。 对象共享接口 你已经对继承和组合的概念有了初步的了解，现在来手搓一个计算器吧🤓👆 通过上一节，对继承和组合有了一定的了解后，是时候将其运用于实际项目中了。 为了内容能够同时涵盖组合与继承，我们选取源码中概念综合度相对较高的平面操作模块为例展开解读。 整个平面模块的代码如下： class PlaneOperation: \u0026#39;\u0026#39;\u0026#39;The operation interface for plane which represent with geometrical represent or algebraic represent in space.\u0026#39;\u0026#39;\u0026#39; type_tag = \u0026#39;plane\u0026#39; @property def normal_vector(self) -\u0026gt; VectorWithCoordinate: if self.branch == \u0026#39;geometry\u0026#39;: vector_a = VectorWithPoint(self.point_1, self.point_2) vector_b = VectorWithPoint(self.point_1, self.point_3) return vector_a.cross_product(vector_b) elif self.branch == \u0026#39;algebra\u0026#39;: return VectorWithCoordinate(self.A, self.B, self.C) def normal_vec_repr(self): assert isinstance(self, PlaneWithGeo), \u0026#39;\u0026#39;\u0026#39;A point argument is required, while the object dosen\u0026#39;t have.\u0026#39;\u0026#39;\u0026#39; return f\u0026#39;{self.normal_vector.x}(x-{self.point_1.x}) + {self.normal_vector.y}(y-{self.point_1.y}) + {self.normal_vector.z}(z-{self.point_1.z}) = 0\u0026#39; def general_repr(self): if self.branch == \u0026#39;geometry\u0026#39;: self.constant = self.point_1.x*self.normal_vector.x + self.point_1.y*self.normal_vector.y + self.point_1.z*self.normal_vector.z return f\u0026#39;{self.normal_vector.x}x + {self.normal_vector.y}y + {self.normal_vector.z}z + {self.constant} = 0\u0026#39; def intercept_repr(self): if self.normal_vector.x == 0: self.a = 0 else: self.a = -(self.constant/self.normal_vector.x) if self.normal_vector.y == 0: self.b = 0 else: self.b = -(self.constant/self.normal_vector.y) if self.normal_vector.z == 0: self.c = 0 else: self.c = -(self.constant/self.normal_vector.z) if self.branch == \u0026#39;geometry\u0026#39;: self.constant = self.point_1.x*self.normal_vector.x + self.point_1.y*self.normal_vector.y + self.point_1.z*self.normal_vector.z return f\u0026#39;x/{self.a} + y/{self.b} + z/{self.c} = 1\u0026#39; def angle(self, other: VectorOperation) -\u0026gt; list: cos_a = (self.normal_vector.quantity_product(other.normal_vector)) / self.normal_vector.magnitude * other.normal_vector.magnitude angle = acos(cos_a) return [cos_a, f\u0026#39;{angle/pi}pi\u0026#39;] def is_vertical(self, other: VectorOperation) -\u0026gt; bool: return self.angle(other)[0] == 0 def is_parallel(self, other: VectorOperation) -\u0026gt; bool: return self.normal_vector.cross_product(other.normal_vector).magnitude == 0 def distance_to_plane(self, point: Point) -\u0026gt; float: assert isinstance(point, Point), \u0026#39;\u0026#39; A = self.normal_vector.x B = self.normal_vector.y C = self.normal_vector.z x0 = point.x; y0 = point.y; z0 = point.z return fabs(A*x0 + B*y0 + C*z0 + self.constant) / self.normal_vector.magnitude def point_at_plane(self, point: Point) -\u0026gt; bool: return self.normal_vector.x * point.x + self.normal_vector.y * point.y + self.normal_vector.z * point.z + self.constant == 0 class PlaneWithGeo(PlaneOperation): \u0026#39;\u0026#39;\u0026#39;Plane construct by geometrical elements.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;geometry\u0026#39; def __init__(self, point_1: Point, point_2: Point, point_3: Point): super().__init__() self.point_1 = point_1 self.point_2 = point_2 self.point_3 = point_3 @property def constant(self): return -(self.normal_vector.x*self.point_1.x + self.normal_vector.y*self.point_1.y + self.normal_vector.z*self.point_1.z) def __repr__(self): return f\u0026#39;Plane({super().normal_vec_repr()})\u0026#39; def __str__(self): return f\u0026#39;{PlaneOperation.type_tag}-{self.point_1.name}{self.point_2.name}{self.point_3.name}\u0026#39; class PlaneWithAlg(PlaneOperation): \u0026#39;\u0026#39;\u0026#39;Plane construct by algebraic elements.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;algebra\u0026#39; def __init__(self, A, B, C, constant): super().__init__() self.A = A self.B = B self.C = C self.constant = constant def __repr__(self): return f\u0026#39;Plane({super().general_repr()})\u0026#39; def __str__(self): return f\u0026#39;{PlaneOperation.type_tag}: {super().general_repr()}\u0026#39; 看似很长，将其拆分来看并辅以课程思想实则非常简单。 快速过一遍源码，不难看出PlaneWithGeo与PlaneWithAlg均继承于PlaneOperation。现在我们将注意力转移到PlaneOperation上，注意到这个类的定义中并没有构造器，只有一些方法。这些方法所定义的就是针对平面的操作或运算，我们暂时忽略这些实现的细节，着眼于整个PlaneOperation与其派生类（子类）的继承关系。 不难发现同属“平面”的两种形态的运算定义共享于它们共同的父类，用上一节所提到的关系说明就是几何形态平面和代数形态平面都是平面。同时，这里我们可以可以换一个角度理解，根据前句提到的关系，我们也可以说几何形态的平面与代数形态的平面都可以通过一个统一的接口相互地进行操作与运算，因为它们都是平面。而我们就把这个统一的接口（这里即PlaneOperation）称为继承于它的多态对象的共享接口。 从整个平面操作模块内部来看，我们定义了平面的多态，并且在他们的父类中定义了操作平面的共享接口。现在，我们将目光放在第一个子类的构造器上，可以看出我们在构造时传入了Point类的实例作为PlaneWithGeo的实例属性，其在数学上的定义就是三点确定一个平面，在组合关系上，我们就可以将其描述为平面上有三个点。 总结 在这篇文章中，我们介绍了python面向对象编程中继承与组合的机制，通过一个简易项目分析了其在对象抽象的运用。以上分析为个人学习理解，尚有不足之处，系统性的知识还请参考cs61a的课程note。 ",
    
    "date": "2025-03-16 22:48:10",
    "updated": "2025-03-18 10:09:00"
  }
  
  , 
  {
    "objectID": "1741572555",
    "permalink": "/post/hello/hello/",
    "title": "Hello :)",
    
    "content": "This is the first content for my blog :) GIF source: Hello Apple by Meritt Thomas ",
    
    "date": "2025-03-10 10:09:15",
    "updated": "2025-03-11 10:09:15"
  }
  
]