
[
  
  
  {
    "objectID": "1742259610",
    "permalink": "/post/fpga_gpu/gpu_researching/",
    "title": "基于FPGA的图形加速器实现：FPGA-GPU项目日志",
    
    "content": " 导言 在互联网上，我们能够找到数不胜数的有关手搓CPU的项目资料，甚至有大佬为此出版专门的教程，但很少能够看到有关GPU的资料。\n本次项目旨在通过参考网上上少有的资料，基于FPGA（现场可编程门阵列）实现一个寄存器传输级（RTL）的图形加速器，即显卡或GPU（Graphics Processing Unit）。当然，商业级的显卡与单纯的GPU芯片并不是同一个概念，我们的目标仅仅只是设计一个能够加速图形渲染速度的IP核（Intellectual Property Core）。 项目主要分为两个阶段：模板复现与功能扩展。 在模板复现阶段，我们将根据知乎文章从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理的指导复现出其中的图形渲染场景。 Let\u0026rsquo;s begin our journey! 项目名称：FPGA-GPU\n项目成员：virtualguard_C 项目指导：vigosser_L 项目核心参考：从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理\n项目核心参考代码仓库：PainterEngine\n复现阶段 预备阶段 提出项目，验证可行性 收集相关理论资料 预备开发环境 第0周（2025.3.15-16） 2025.3.15晚: 项目指导提出项目，提供核心参考文献（以下简称原文）从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理，项目启动 2025.3.16: 第一次线下交流，确定方向\n通过直接询问核心参考文献作者（以下简称作者）及ai查询相结合的方式，解决C项目在linux系统上（Ubuntu22.04）的编译配置问题（Makefile配置），成功复现上层C语言层面的软渲染器实现。具体配置如下：\nwinodws系统配置和其他具体过程这里不再赘述，详情可参考原文，这里只说明在linux上的编译配置。\n创建独立的项目目录，并将软渲染实现的c源码从克隆或解压缩后的源项目路径复制过来：\nmkdir -p workspace cd ./workspace cp /path/to/PainterEngine/platform/fpga_gpu/simulator/* . 复制Makefile并进行修改：\ncp /path/to/PainterEngine/platform/linux/makefile . code ./makefile Makefile配置如下： - code_01\n#gcc freeglut makefile ##################################################### target :=painterEngine project_path := /path/to/workspace painterengine_path := /path/to/PainterEngine/ ##################################################### project_build := $(wildcard $(project_path)/*.c) project_build_cpp = $(wildcard $(project_path)/*.cpp) project_build_o := $(patsubst %.c,%.o,$(project_build)) project_build_o += $(patsubst %.cpp,%.o,$(project_build_cpp)) painterengine_build_core := $(wildcard $(painterengine_path)/core/*.c) painterengine_build_painterengine_o := $(patsubst %.c,%.o,$(painterengine_build_core)) painterengine_build_kernel := $(wildcard $(painterengine_path)/kernel/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_kernel)) painterengine_build_runtime := $(wildcard $(painterengine_path)/runtime/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_runtime)) painterengine_build_platform := $(wildcard $(painterengine_path)/platform/linux/*.c) painterengine_build_painterengine_o += $(patsubst %.c,%.o,$(painterengine_build_platform)) painterengine_build_platform := $(wildcard $(painterengine_path)/platform/linux/*.cpp) painterengine_build_painterengine_o += $(patsubst %.cpp,%.o,$(painterengine_build_platform)) all:$(project_build_o) $(painterengine_build_painterengine_o) gcc $(project_build_o) $(painterengine_build_painterengine_o) \\ -o $(target) \\ -I \u0026#34;$(painterengine_path)\u0026#34; \\ -I \u0026#34;$(project_path)\u0026#34; \\ -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; \\ -I \u0026#34;$(painterengine_path)/runtime\u0026#34; \\ -L. -lGL -lglut -lpthread $(project_path)/%.o:$(project_path)/%.c gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; $(project_path)/%.o:$(project_path)/%.cpp gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; $(painterengine_path)/runtime/%.o:$(painterengine_path)/runtime/%.c gcc -c $^ -o $@ -I \u0026#34;$(painterengine_path)\u0026#34; $(painterengine_path)/kernel/%.o:$(painterengine_path)/kernel/%.c gcc -c $^ -o $@ $(painterengine_path)/core/%.o:$(painterengine_path)/core/%.c gcc -c $^ -o $@ $(painterengine_path)/platform/linux/%.o:$(painterengine_path)/platform/linux/%.c gcc -c $^ -o $@ -I \u0026#34;$(project_path)\u0026#34; -I \u0026#34;$(painterengine_path)\u0026#34; -I \u0026#34;$(painterengine_path)/platform/linux\u0026#34; -I \u0026#34;$(painterengine_path)/runtime\u0026#34; clean: find $(painterengine_path) -type f -name \u0026#34;*.o\u0026#34; -exec rm -f {} + find $(painterengine_path) -type f -name \u0026#34;a.out\u0026#34; -exec rm -f {} + 相比较源项目需要正确修改项目路径和PainterEngine所在路径，这里我们还添加了make clean的配置。\n修改完成后，务必检查路径是否配置正确，随后即可开始编译：\nmake all -f ./makefile 编译完成后，运行生成于当前路径的painterEngine可执行程序，即可成功复现原文对应内容。\n第1周（2025.3.17-23） 2025.3.17 开始汇总基础依赖，收集相关理论资料 根据原文主要需要以下方面的基础知识： 1.C语言基础、verilog基础\n2.计算机组成原理/计算机系统基础\n3.计算机图形学基础\n4.数字电路基础\n5.通信原理基础\n6.FPGA设计基础\n获取FPAG编译工具Vivado与Vitis 注意版本问题，最佳版本为2024.02，过老的版本会出现无法打开原文项目的问题。\n另外需要注意的是，运行Vivado对设备硬件有一定需求，主要参考设备CPU的单核性能以及内存容量，内存最好在32G以上。同时，虽然Vivado存在linux版本，但安装过程相当繁琐，且极易出现兼容性问题，故不展开。\n在安装过程中，需要AMD的官方账号，安装时需要的地址信息可通过美国地址生成器生成。\n参考资料：\n原文评论区 - resource_01\nVivado全版本下载分享 - resource_02\nVivado安装问题（linux） - resource_03\nVivado 2018.3 下载及安装 - resource_04\n基础概念了解 这个方式多样，需要日积月累，碎片化的概念可以通过AI和浏览器查询；也可以在一些平台上阅读一些相关的文章，反向利用大数据的推送机制。\n芯片基础概念划分 - resource_05\n系统性的知识体系可以通过一些书籍和课程来学习\ncsapp：深入理解计算机系统 -resource_06\ncsapp中文讲解 - resource_07\nGPU架构开源资料（项目指导提供） tiny-gpu | github repository - resource_08\nFlexGripPlus-兼容CUDA的开源GPGPU实现简介 - resource_09\nFlexGripPlus | github repository - resource_10\n2025.3.18 初始化项目日志 是的，就是这个你正在看的玩意\n获取硬件（型号ZYNQ-xc7z020clg484-1） 硬件平台是Zynq7000系列的SoC开发板, 详情参考原文\n硬件详细资料 - resource_01\nAMD官方文档 - resource_02\n基础理论学习阶段 依据预备阶段收集到的基础依赖进行基础理论学习 进一步收集资料，同时进行消化 注：该阶段过程相对漫长，日志有概率不以逐周形式展开\n2025.3.19 准备阶段基本结束，进入基础理论学习阶段 项目复现核心概念专有名词简要解释 - resource_01\n软渲染器的c语言实现原理 可直接参考项目原文\n从零开始制作一个属于你自己的GPU | 基于FPGA的图形加速器实现原理 - resource_02\n其实就是我们在预备阶段配置的demo\n相关理论基础：C语言、计算机图形学\nGAMES101: 现代计算机图形学入门 - resource_03\n《Fundamental Of Computer Graphics 4th Edition》（计算机图形学基础） - resource_04\n《计算机图形学：原理与实践（基础版）》| 机械工业出版社 - resource_05\n2025.3.20 针对【Rs-250319】（注：此后本日志以{data(id)}-date形式指代对应日期（一般是首次）整理至此的参考文献、问题等资料，方便回溯。例如【Rs-250319】指2025.3.19的所有resource；【Q01-250325】指2025.3.25的question_01），为了节约时间，我们无需全篇通读，仅需了解与项目对应的概念。\n例如，针对《计算机图形学：原理与实践（基础版）》，我们只需迅速地通读七至十五章的内容，对计算机图形学的数学原理和基础概念与实现作个快速了解即可。\n另外，由于C++面向对象的特性，图形学在编程过程中更倾向于使用C++而不是C（虽然二者在语法上差别不大），《计算机图形学：原理与实践（基础版）》中的测试实现语言也是C++，故在此整理如下参考文献：\nPython to C++ Guide | CS106B - resource_01\nC++ 教程 | 菜鸟教程 - resource_02\n2025.3.22 soc主板上电测试成功 - image_01\n- image_02\n这里采用的是测试固件二，结果标准参考硬件详细资料 - resource_01\n上传计算机图形学材料（🐯书原版第四版 | 文件来源：z-library） 即【R04-250319】的英文原版\n《Fundamental Of Computer Graphics 4th Edition》 - resource_02\n2025.3.23 针对计算机图形学的基础概念了解基本结束 主要参考材料：【R04-250319】的第二章及第三章\n需要注意的是，计算机图形学模块并非我们项目复现阶段的主要基础依赖，对其涉猎的数学基础及图形光栅化的概念有个初步了解即可。\n上传计算机系统基础材料（《csapp：深入理解计算机系统》3th-中译版 | 文件来源：z-library） 《深入理解计算机系统（原书第3版）》 - resource_01\n接下来即进入本项目核心基础依赖的学习：计算机系统基础\n尽管针对该基础依赖，本项目仍然只运用到其中的一小部分内容（第四章与第六章），但介于计算机系统基础在计算机学习中的重要地位，还是建议尽可能的吃透它。\n针对该基础内容，该日志的前文收录了相关的官方课程与中文讲解：\n官方课程：【R06-250317】\n中文讲解：【R07-250317】\n2025.3.24 开始学习计算机系统-处理器架构 《csapp》对应章节为第一部分第三章\nY86-64架构 | ARCH:VLOG Verilog Implementation of a Pipelined Y86 Processor\n",
    
    "date": "2025-03-18 09:00:10",
    "updated": "2025-03-18 09:00:10"
  }
  
  , 
  {
    "objectID": "1742136490",
    "permalink": "/post/space-calculator/py_oop/",
    "title": "多态对象共享接口：一个简易立体几何计算器的python实现",
    
    "content": " 导言 学习了cs61a的有关python面向对象的课程（函数式编程没有去细看，本文内容也与之无关），对面向对象的思想有了更加深刻的理解，特别是在多态对象的统一接口思想上，其在实现上主要运用了python对象系统的继承及组合机制（详情可以参考cs61a的课程资料）。当然，不是只有python才具有继承与组合机制，几乎所有的面向对象语言都支持继承与组合。 将上面的思想与数学中立体几何的各种定义结合起来，就有了下面这个项目👇 项目网址：Space Calculator 本文主要结合cs61a的课程思想，通过核心代码简要解读一下这个项目的实现框架，针对语法及代码细节不作展开，详情可结合本文自行阅读源码，核心代码位于项目根目录下的/src/space.py 多态对象 一个数据对象可能由不止一种有用的表示，我们也许会想要设计能够处理多种表示形式的系统。这是cs61a对多态对象系统的表述。在构建一个对象时，我们可以从多个角度来描述构建该对象所需要的属性，从而使这个对象有多种表示形态。 举一个简单的例子，一个向量在空间中的表示通常有坐标表示和**分解表示（通常是正交分解）**两种形式，前者在代数运算上具有极大的方便，后者在几何意义的表示上具有优势。因此在构造一个向量时，我们就可以通过两种方式进行构造： class VectorWithPoint(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with point.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;geometry\u0026#39; def __init__(self, point_start: Point, point_end: Point): super().__init__() self.point_s = point_start self.point_e = point_end def __repr__(self): super().__init__() return f\u0026#39;Vector({self.point_s.name}{self.point_e.name}) == {VectorWithCoordinate((self.point_e.x - self.point_s.x), (self.point_e.y - self.point_s.y), (self.point_e.z - self.point_s.z))}\u0026#39; def __str__(self): return f\u0026#39;{self.point_s.name.upper()}-\u0026gt;{self.point_e.name.upper()}\u0026#39; class VectorWithCoordinate(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with coordinate.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;algebra\u0026#39; def __init__(self, x, y, z): super().__init__() self.x = x self.y = y self.z = z def __repr__(self): return f\u0026#39;Vector({self.x}i + {self.y}j + {self.z}k)\u0026#39; def __str__(self): return f\u0026#39;({self.x}, {self.y}, {self.z})\u0026#39; 通过上面的py代码中，我们可以通过**几何元素（点）和代数元素（坐标）**两种形态来构造和表示一个向量对象，从而为我们后续的可能需要的操作作铺垫。 组合、继承与对象接口 继承与组合 继承是面向对象编程中一个强大的机制，它允许一个子类从其所继承的父类继承属性和方法。我们通过将计算结果为基类（父类）的表达式放在类名后面的括号中来指定继承。\nclass VectorOperation: \u0026#39;\u0026#39;\u0026#39;The operation interface for vector which represent with coordinate or point in space.\u0026#39;\u0026#39;\u0026#39; class VectorWithPoint(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with point.\u0026#39;\u0026#39;\u0026#39; class VectorWithCoordinate(VectorOperation): \u0026#39;\u0026#39;\u0026#39;Vector represent with coordinate.\u0026#39;\u0026#39;\u0026#39; 在上面的代码中，类VectorWithCoordinate、VectorWithPoint均继承于VectorOperation。 对于类的继承，我们通常以is-a即xx是一个xx来描述子类与父类之间的关系，从上面的例子来看就是几何形态向量与坐标形态向量都是一个向量（所以从定义角度来看，VectorOperation应该改为Vector）。\n在面向对象中，还有一个概念称为类的组合，以has-a即xx有一个xx来描述二者的关系。举一个简单的例子：\nclass Lessons: def __init__(self, name, teacher, grade): self.name = name self.teacher = teacher self.grade = grade class Students: def __init__(self, name, id): self.name = name self.id = id self.lesson = Lessons(\u0026#39;python-oop\u0026#39;, \u0026#39;cs61a\u0026#39;, 4.0) def __repr__(self): return f\u0026#39;name: {self.name} id: {self.id} \\ lesson: {self.lesson.name}\u0026#39; 在上面的代码中，我们定义了两个类：Lessons和Students，其中Students的构造函数中将Lessons的一个实例作为一个属性，用上面的关系来说明就是学生有一门课程。在面向对象编程中，组合相比起继承更加灵活，因为后者所定义的类与类之间的关系是静态的，前者反之。 在这个项目中，我们对组合的运用同样无处不在。在数学关系上，各个概念之间的关系是确定的，不需要动态调整，因此我们在这里更加倾向于使用继承来描述类于类之间的关系；而在定义操作各个数学元素的运算概念时，组合灵活的优势就能得到极大的发挥。定义运算的地方和方法就是下文将要重点介绍的对象。 对象共享接口 你已经对继承和组合的概念有了初步的了解，现在来手搓一个计算器吧🤓👆 通过上一节，对继承和组合有了一定的了解后，是时候将其运用于实际项目中了。 为了内容能够同时涵盖组合与继承，我们选取源码中概念综合度相对较高的平面操作模块为例展开解读。 整个平面模块的代码如下： class PlaneOperation: \u0026#39;\u0026#39;\u0026#39;The operation interface for plane which represent with geometrical represent or algebraic represent in space.\u0026#39;\u0026#39;\u0026#39; type_tag = \u0026#39;plane\u0026#39; @property def normal_vector(self) -\u0026gt; VectorWithCoordinate: if self.branch == \u0026#39;geometry\u0026#39;: vector_a = VectorWithPoint(self.point_1, self.point_2) vector_b = VectorWithPoint(self.point_1, self.point_3) return vector_a.cross_product(vector_b) elif self.branch == \u0026#39;algebra\u0026#39;: return VectorWithCoordinate(self.A, self.B, self.C) def normal_vec_repr(self): assert isinstance(self, PlaneWithGeo), \u0026#39;\u0026#39;\u0026#39;A point argument is required, while the object dosen\u0026#39;t have.\u0026#39;\u0026#39;\u0026#39; return f\u0026#39;{self.normal_vector.x}(x-{self.point_1.x}) + {self.normal_vector.y}(y-{self.point_1.y}) + {self.normal_vector.z}(z-{self.point_1.z}) = 0\u0026#39; def general_repr(self): if self.branch == \u0026#39;geometry\u0026#39;: self.constant = self.point_1.x*self.normal_vector.x + self.point_1.y*self.normal_vector.y + self.point_1.z*self.normal_vector.z return f\u0026#39;{self.normal_vector.x}x + {self.normal_vector.y}y + {self.normal_vector.z}z + {self.constant} = 0\u0026#39; def intercept_repr(self): if self.normal_vector.x == 0: self.a = 0 else: self.a = -(self.constant/self.normal_vector.x) if self.normal_vector.y == 0: self.b = 0 else: self.b = -(self.constant/self.normal_vector.y) if self.normal_vector.z == 0: self.c = 0 else: self.c = -(self.constant/self.normal_vector.z) if self.branch == \u0026#39;geometry\u0026#39;: self.constant = self.point_1.x*self.normal_vector.x + self.point_1.y*self.normal_vector.y + self.point_1.z*self.normal_vector.z return f\u0026#39;x/{self.a} + y/{self.b} + z/{self.c} = 1\u0026#39; def angle(self, other: VectorOperation) -\u0026gt; list: cos_a = (self.normal_vector.quantity_product(other.normal_vector)) / self.normal_vector.magnitude * other.normal_vector.magnitude angle = acos(cos_a) return [cos_a, f\u0026#39;{angle/pi}pi\u0026#39;] def is_vertical(self, other: VectorOperation) -\u0026gt; bool: return self.angle(other)[0] == 0 def is_parallel(self, other: VectorOperation) -\u0026gt; bool: return self.normal_vector.cross_product(other.normal_vector).magnitude == 0 def distance_to_plane(self, point: Point) -\u0026gt; float: assert isinstance(point, Point), \u0026#39;\u0026#39; A = self.normal_vector.x B = self.normal_vector.y C = self.normal_vector.z x0 = point.x; y0 = point.y; z0 = point.z return fabs(A*x0 + B*y0 + C*z0 + self.constant) / self.normal_vector.magnitude def point_at_plane(self, point: Point) -\u0026gt; bool: return self.normal_vector.x * point.x + self.normal_vector.y * point.y + self.normal_vector.z * point.z + self.constant == 0 class PlaneWithGeo(PlaneOperation): \u0026#39;\u0026#39;\u0026#39;Plane construct by geometrical elements.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;geometry\u0026#39; def __init__(self, point_1: Point, point_2: Point, point_3: Point): super().__init__() self.point_1 = point_1 self.point_2 = point_2 self.point_3 = point_3 @property def constant(self): return -(self.normal_vector.x*self.point_1.x + self.normal_vector.y*self.point_1.y + self.normal_vector.z*self.point_1.z) def __repr__(self): return f\u0026#39;Plane({super().normal_vec_repr()})\u0026#39; def __str__(self): return f\u0026#39;{PlaneOperation.type_tag}-{self.point_1.name}{self.point_2.name}{self.point_3.name}\u0026#39; class PlaneWithAlg(PlaneOperation): \u0026#39;\u0026#39;\u0026#39;Plane construct by algebraic elements.\u0026#39;\u0026#39;\u0026#39; branch = \u0026#39;algebra\u0026#39; def __init__(self, A, B, C, constant): super().__init__() self.A = A self.B = B self.C = C self.constant = constant def __repr__(self): return f\u0026#39;Plane({super().general_repr()})\u0026#39; def __str__(self): return f\u0026#39;{PlaneOperation.type_tag}: {super().general_repr()}\u0026#39; 看似很长，将其拆分来看并辅以课程思想实则非常简单。 快速过一遍源码，不难看出PlaneWithGeo与PlaneWithAlg均继承于PlaneOperation。现在我们将注意力转移到PlaneOperation上，注意到这个类的定义中并没有构造器，只有一些方法。这些方法所定义的就是针对平面的操作或运算，我们暂时忽略这些实现的细节，着眼于整个PlaneOperation与其派生类（子类）的继承关系。 不难发现同属“平面”的两种形态的运算定义共享于它们共同的父类，用上一节所提到的关系说明就是几何形态平面和代数形态平面都是平面。同时，这里我们可以可以换一个角度理解，根据前句提到的关系，我们也可以说几何形态的平面与代数形态的平面都可以通过一个统一的接口相互地进行操作与运算，因为它们都是平面。而我们就把这个统一的接口（这里即PlaneOperation）称为继承于它的多态对象的共享接口。 从整个平面操作模块内部来看，我们定义了平面的多态，并且在他们的父类中定义了操作平面的共享接口。现在，我们将目光放在第一个子类的构造器上，可以看出我们在构造时传入了Point类的实例作为PlaneWithGeo的实例属性，其在数学上的定义就是三点确定一个平面，在组合关系上，我们就可以将其描述为平面上有三个点。 总结 在这篇文章中，我们介绍了python面向对象编程中继承与组合的机制，通过一个简易项目分析了其在对象抽象的运用。以上分析为个人学习理解，尚有不足之处，系统性的知识还请参考cs61a的课程note。 ",
    
    "date": "2025-03-16 22:48:10",
    "updated": "2025-03-18 10:09:00"
  }
  
  , 
  {
    "objectID": "1741572555",
    "permalink": "/post/hello/hello/",
    "title": "Hello :)",
    
    "content": "This is the first content for my blog :) GIF source: Hello Apple by Meritt Thomas ",
    
    "date": "2025-03-10 10:09:15",
    "updated": "2025-03-10 10:09:15"
  }
  
]